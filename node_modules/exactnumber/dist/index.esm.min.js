/*!
 * exactnumber v1.0.1 (https://www.npmjs.com/package/exactnumber)
 * (c) Dani Biro
 * @license MIT
 */

var t,r;!function(t){t[t.NEAREST_TO_POSITIVE=201008]="NEAREST_TO_POSITIVE",t[t.NEAREST_TO_NEGATIVE=201009]="NEAREST_TO_NEGATIVE",t[t.NEAREST_TO_EVEN=201010]="NEAREST_TO_EVEN",t[t.NEAREST_TO_ZERO=201011]="NEAREST_TO_ZERO",t[t.NEAREST_AWAY_FROM_ZERO=201012]="NEAREST_AWAY_FROM_ZERO",t[t.TO_POSITIVE=201001]="TO_POSITIVE",t[t.TO_NEGATIVE=201002]="TO_NEGATIVE",t[t.TO_ZERO=201003]="TO_ZERO",t[t.AWAY_FROM_ZERO=201004]="AWAY_FROM_ZERO"}(t||(t={})),function(t){t.TRUNCATED="T",t.FLOORED="F",t.EUCLIDEAN="E"}(r||(r={}));const e=t=>{const r=t.indexOf(".");if(-1===r)return t;let e=t.length;for(;e>r&&"0"===t.charAt(e-1);)e--;const n=r===e-1?r:e;return 0===n?"0":t.slice(0,n)},n=(t,r,n,i)=>{let o=t.toString();if(0===r&&0===n)return o;const s=o.startsWith("-");if(s&&(o=o.slice(1)),r>=o.length&&(o="0".repeat(r-o.length+1)+o),r>0){const t=o.slice(0,-r),s=o.slice(-r),u=n<=r?s.slice(0,n):`${s}${"0".repeat(n-r)}`;0!==u.length?(o=`${t}.${u}`,i&&(o=e(o))):o=t}else n>0&&!i&&(o=`${o}.${"0".repeat(n)}`);return s?`-${o}`:o},i=(r,e)=>(r=r.normalize())instanceof d?r.round(e,t.NEAREST_AWAY_FROM_ZERO):r,o=BigInt(0),s=BigInt(1),u=BigInt(2),a=BigInt(3),c=BigInt(4),m=BigInt(5),l=BigInt(10),h=BigInt(24);class d{constructor(t,r=0){if(this.type="fixed","bigint"==typeof t)this.number=t,this.decimalPos=r;else{const r=this.parseConstructorParameter(t);this.number=r.number,this.decimalPos=r.decimalPos}}parseConstructorParameter(t){if(t instanceof d)return{number:t.number,decimalPos:t.decimalPos};if(t instanceof f){if(!t.isInteger())throw new Error("Cannot create FixedNumber from non-integer Fraction");return{number:t.trunc().number,decimalPos:0}}if("number"==typeof t){if(!Number.isSafeInteger(t))throw new Error("The specified number cannot be exactly represented as an integer. Please provide a string instead.");return{number:BigInt(t),decimalPos:0}}if("string"==typeof t){if(0===(t=t.trim()).length)throw new Error("Empty string is not allowed");const r=t.match(/^(-?[0-9]*)(?:\.([0-9]*))?(?:[eE]([+-]?[0-9]+))?$/);if(!r)throw new Error(`Cannot parse number "${t}"`);let e=0,n=r[1]??"0";if(void 0!==r[2]&&(n+=r[2],e+=r[2].length),void 0!==r[3]){const t=Number(r[3]);t>0?n+="0".repeat(t):e-=t}return{number:BigInt(n),decimalPos:e}}throw new Error("Unsupported parameter!")}scaleNumber(t,r){const e=Math.max(this.decimalPos,r);return{a:e===this.decimalPos?this.number:this.number*l**BigInt(e-this.decimalPos),b:e===r?t:t*l**BigInt(e-r),decimalPos:e}}add(t){const r=g(t);if(r instanceof f)return r.add(this);const e=r,{a:n,b:i,decimalPos:o}=this.scaleNumber(e.number,e.decimalPos);return new d(n+i,o)}sub(t){const r=g(t);return this.add(r.neg())}mul(t){const r=g(t);if(r instanceof f)return r.mul(this);const e=r,n=this.number*e.number;return new d(n,this.decimalPos+e.decimalPos)}pow(t){const r=g(t).toNumber();if(!Number.isSafeInteger(r))throw new Error("Unsupported parameter");const e=Math.abs(r),n=new d(this.number**BigInt(e),this.decimalPos*e);return r<0?n.inv():n}powm(t,r,e){let n=g(t).toNumber();if(!Number.isSafeInteger(n))throw new Error("Unsupported parameter");const i=g(r);let o=this,a=new d(s);for(;0!==n;)n%2!=0&&(a=a.mul(o).mod(i,e)),o=o.pow(u).mod(i,e),n=Math.floor(n/2);return a}div(t){return this.convertToFraction().div(t)}divToInt(t){const r=g(t);if(r instanceof f)return this.convertToFraction().divToInt(r);const e=r,{a:n,b:i}=this.scaleNumber(e.number,e.decimalPos);return new d(n/i)}mod(t,e=r.TRUNCATED){const n=g(t);if(n instanceof f)return this.convertToFraction().mod(n);const i=n,{a:s,b:u,decimalPos:a}=this.scaleNumber(i.number,i.decimalPos),c=s%u,m=new d(c,a);if(e===r.TRUNCATED)return m;if(e===r.FLOORED)return Number(s<o)^Number(u<o)?m.add(u):m;if(e===r.EUCLIDEAN)return c<o?m.add(u<o?-u:u):m;throw new Error("Invalid ModType")}abs(){return new d(this.number<o?-this.number:this.number,this.decimalPos)}neg(){return this.mul(-s)}inv(){return this.convertToFraction().inv()}floor(r){return 0===this.decimalPos?this:this.round(r,t.TO_NEGATIVE)}ceil(r){return 0===this.decimalPos?this:this.round(r,t.TO_POSITIVE)}trunc(r){return 0===this.decimalPos?this:this.round(r,t.TO_ZERO)}isTieStr(t){if("5"!==t[0])return!1;for(let r=1;r<t.length;r++)if("0"!==t[r])return!1;return!0}_round(r,e){const n=this.decimalPos-r;if(n<=0)return this;const i=l**BigInt(n),a=this.number/i;if(e===t.TO_ZERO)return new d(a,r);const c=this.number%i;if(c===o)return new d(a,r);if(e===t.AWAY_FROM_ZERO){const t=this.number<o?a-s:a+s;return new d(t,r)}if(e===t.TO_POSITIVE){const t=this.number<o?a:a+s;return new d(t,r)}if(e===t.TO_NEGATIVE){const t=this.number>=o?a:a-s;return new d(t,r)}if(![void 0,t.NEAREST_TO_ZERO,t.NEAREST_AWAY_FROM_ZERO,t.NEAREST_TO_POSITIVE,t.NEAREST_TO_NEGATIVE,t.NEAREST_TO_EVEN].includes(e))throw new Error("Invalid rounding mode. Use the predefined values from the RoundingMode enum.");let m=(c<o?-c:c).toString();if(m.length<n&&(m="0"),this.isTieStr(m)){if(e===t.NEAREST_TO_ZERO)return new d(a,r);if(e===t.NEAREST_AWAY_FROM_ZERO){const t=this.number<o?a-s:a+s;return new d(t,r)}if(void 0===e||e===t.NEAREST_TO_POSITIVE){const t=this.number<o?a:a+s;return new d(t,r)}if(e===t.NEAREST_TO_NEGATIVE){const t=this.number>=o?a:a-s;return new d(t,r)}if(e===t.NEAREST_TO_EVEN){if(a%u===o)return new d(a,r);return new d(a<o?a-s:a+s,r)}}if(Number(m[0])<5)return new d(a,r);const h=this.number<o?a-s:a+s;return new d(h,r)}round(t,r){if(t=void 0===t?0:t,!Number.isSafeInteger(t)||t<0)throw new Error("Invalid value for decimals");return this._round(t,r).normalize()}_incExponent(t){if(0===t)return this;let r=this.number,e=this.decimalPos;if(t<0)e-=t;else{const n=Math.min(t,this.decimalPos);e-=n;const i=t-n;i>0&&(r*=l**BigInt(i))}return new d(r,e)}countDigits(){if(this.number===o)return 1;let t=0,r=this.number<o?-this.number:this.number;for(;r>o;)r/=l,t++;return t}toSubZeroNum(){const t=this.countDigits();return{subZeroNum:new d(this.number,t),exponentDiff:t-this.decimalPos}}roundToDigits(t,r){if(!Number.isSafeInteger(t)||t<1)throw new Error("Invalid value for digits");const{subZeroNum:e,exponentDiff:n}=this.toSubZeroNum();let i=e.round(t,r);return i=i._incExponent(n),i}intPart(){return this.trunc()}fracPart(){return this.sub(this.trunc())}sign(){return this.number<o?-1:1}bitwiseAnd(t){if(t=w(t),!this.isInteger()||-1===this.sign()||!t.isInteger()||-1===t.sign())throw new Error("Only positive integers are supported");t instanceof f&&(t=t.trunc());const r=u**h;let e=this.normalize().number,n=t.trunc().normalize().number,i=o,a=s;for(;e>o&&n>o;){const t=BigInt.asUintN(24,e),o=BigInt.asUintN(24,n);i+=BigInt(Number(t)&Number(o))*a,a*=r,e/=r,n/=r}return new d(i)}bitwiseOr(t){if(t=w(t),!this.isInteger()||-1===this.sign()||!t.isInteger()||-1===t.sign())throw new Error("Only positive integers are supported");t instanceof f&&(t=t.trunc());const r=u**h;let e=this.normalize().number,n=t.trunc().normalize().number,i=o,a=s;for(;e>o||n>o;){const t=BigInt.asUintN(24,e),o=BigInt.asUintN(24,n);i+=BigInt(Number(t)|Number(o))*a,a*=r,e/=r,n/=r}return new d(i)}bitwiseXor(t){if(t=w(t),!this.isInteger()||-1===this.sign()||!t.isInteger()||-1===t.sign())throw new Error("Only positive integers are supported");t instanceof f&&(t=t.trunc());const r=u**h;let e=this.normalize().number,n=t.trunc().normalize().number,i=o,a=s;for(;e>o||n>o;){const t=BigInt.asUintN(24,e),o=BigInt.asUintN(24,n);i+=BigInt(Number(t)^Number(o))*a,a*=r,e/=r,n/=r}return new d(i)}shiftLeft(t){if(!this.isInteger()||-1===this.sign())throw new Error("Only positive integers are supported");if(!Number.isSafeInteger(t)||t<0)throw new Error("Invalid value for bitCount");const r=u**BigInt(t);return this.mul(r)}shiftRight(t){if(!this.isInteger()||-1===this.sign())throw new Error("Only positive integers are supported");if(!Number.isSafeInteger(t)||t<0)throw new Error("Invalid value for bitCount");const r=u**BigInt(t);return new d(this.normalize().number/r)}cmp(t){const r=g(t);if(r instanceof f)return-r.cmp(this);const e=r,{a:n,b:i}=this.scaleNumber(e.number,e.decimalPos);return n===i?0:n>i?1:-1}eq(t){return 0===this.cmp(t)}lt(t){return-1===this.cmp(t)}lte(t){return this.cmp(t)<=0}gt(t){return 1===this.cmp(t)}gte(t){return this.cmp(t)>=0}clamp(t,r){const e=w(t),n=w(r);if(e.gt(n))throw new Error("Min parameter has to be smaller than max");return this.lt(e)?e:this.gt(n)?n:this}isZero(){return this.number===o}isOne(){if(0===this.decimalPos)return this.number===s;const t=l**BigInt(this.decimalPos),r=this.number/t;return r===s&&r*t===this.number}isInteger(){return 0===this.decimalPos||this.number%l**BigInt(this.decimalPos)===o}serialize(){return[this.number,this.decimalPos]}getFractionParts(t=!0){return this.convertToFraction().getFractionParts(t)}normalize(){if(0===this.decimalPos)return this;let t=this.decimalPos,r=this.number;for(;t>0&&r%l===o;)t--,r/=l;return new d(r,t)}convertToFraction(){if(0===this.decimalPos)return new f(this.number,s);const t=l**BigInt(this.decimalPos);return new f(this.number,t)}toNumber(){return Number(this.toPrecision(20))}toFixed(r,e=t.TO_ZERO,i=!1){if(!Number.isSafeInteger(r)||r<0)throw new Error("Invalid parameter");const o=this._round(r,e);return n(o.number,o.decimalPos,r,i)}toExponential(r,n=t.TO_ZERO,i=!1){if(!Number.isSafeInteger(r)||r<0)throw new Error("Invalid parameter");const o=this.roundToDigits(r+1,n).normalize(),s=-1===o.sign(),u=o.abs(),a=u.number.toString(),c=a.length<=r?`${a}${"0".repeat(r-a.length+1)}`:a.slice(0,r+1);let m=c;c.length>1&&(m=`${c.slice(0,1)}.${c.slice(1)}`,i&&(m=e(m)));const l=u.decimalPos,h=a.length-1-l;return`${s?"-":""}${m}e${h>=0?"+":""}${h}`}toBase(t,r){if(!Number.isSafeInteger(t)||t<2||t>16)throw new Error("Invalid radix");if(void 0!==r&&(!Number.isSafeInteger(r)||r<0))throw new Error("Invalid parameter");const e=this.normalize();if(0===e.decimalPos)return e.number.toString(t);const n=void 0===r?Number.MAX_SAFE_INTEGER:r;let i=e.intPart(),o=e.sub(i);const s=-1===e.sign();s&&(i=i.neg(),o=o.neg());const u=new Map;let a=[];for(;!o.isZero();){const r=o.mul(t),e=r.toString(),i=u.get(e);if(void 0!==i){a=[...a.slice(0,i-1),"(",...a.slice(i-1),")"];break}if(a.length===n)break;const s=Math.abs(r.intPart().toNumber());a.push(s.toString(t)),o=r.fracPart(),u.set(e,a.length)}const c=a.join("");return`${s?"-":""}${i.number.toString(t)}${a.length?".":""}${c}`}toFraction(){return this.convertToFraction().toFraction()}toString(t,r){if(void 0===t||10===t){const t=void 0!==r?this.trunc(r):this;return n(t.number,t.decimalPos,t.decimalPos,!0)}return this.toBase(t,r)}toPrecision(r,i=t.TO_ZERO,o=!1){if(!Number.isSafeInteger(r)||r<1)throw new Error("Invalid parameter");const s=this.roundToDigits(r,i),{subZeroNum:u,exponentDiff:a}=s.toSubZeroNum(),c=-1===u.sign();let m=n(u.number,u.decimalPos,u.decimalPos,!1);m=m.slice(c?3:2),m=m.slice(0,Math.max(r,a));const l=m.slice(0,Math.max(0,a)),h=m.slice(Math.max(0,a)),d=Math.max(0,r-l.length-h.length),f="0".repeat(a<0?-a:0);let g=l||"0";if(h.length+f.length+d>0){g+=`.${f}${h}${"0".repeat(d)}`,o&&(g=e(g))}return c?`-${g}`:g}valueOf(){throw new Error("Unsafe conversion to Number type! Use toNumber() instead.")}}class f{constructor(t,r){if(this.type="fraction","bigint"==typeof t&&"bigint"==typeof r)this.numerator=t,this.denominator=r;else{const e=this.parseParameter(t),n=this.parseParameter(r),i=e.div(n),o=i instanceof d?i.convertToFraction():i;this.numerator=o.numerator,this.denominator=o.denominator}if(this.denominator===o)throw new Error("Division by zero")}parseRepeatingDecimal(t){if(!t.includes("("))return new d(t).convertToFraction();const r=(t=t.trim()).match(/^(-?[0-9]*)\.([0-9]+)?\(([0-9]+)\)(?:[eE]([+-]?[0-9]+))?$/);if(!r)throw new Error(`Cannot parse string "${t}"`);const e="-"===r[1]?"-0":r[1],n=r[2]??"",i=r[3],o=r[4],s=BigInt(e+n+i)-BigInt(e+n),u=BigInt("9".repeat(i.length)+"0".repeat(n.length)),a=new f(s,u);if(void 0!==o){const t=o.startsWith("-"),r=l**BigInt(t?o.slice(1):o);return t?a.div(r).normalize():a.mul(r).normalize()}return a.simplify()}parseParameter(t){if(t instanceof f)return t;if(t instanceof d)return t.convertToFraction();if("number"==typeof t){if(!Number.isSafeInteger(t))throw new Error("Floating point values as numbers are unsafe. Please provide them as a string.");return new f(BigInt(t),s)}if("bigint"==typeof t)return new f(t,s);if("string"==typeof t){const r=t.split("/");if(r.length>2)throw new Error(`Cannot parse string '${t}'`);const e=this.parseRepeatingDecimal(r[0]),n=r[1]?this.parseRepeatingDecimal(r[1]):new f(s,s);return e.div(n).convertToFraction()}throw new Error("Unsupported parameter!")}add(t){const{numerator:r,denominator:e}=this.parseParameter(t);return this.denominator===e?new f(this.numerator+r,this.denominator):new f(this.numerator*e+r*this.denominator,e*this.denominator)}sub(t){const{numerator:r,denominator:e}=this.parseParameter(t);return this.add(new f(-r,e))}mul(t){const{numerator:r,denominator:e}=this.parseParameter(t);return new f(this.numerator*r,this.denominator*e)}div(t){const{numerator:r,denominator:e}=this.parseParameter(t);return this.mul(new f(e,r))}divToInt(t){return this.div(t).trunc()}mod(t,e=r.TRUNCATED){const n=this.parseParameter(t),i=n.denominator*this.numerator%(n.numerator*this.denominator),o=this.denominator*n.denominator,s=new f(i,o);if(e===r.TRUNCATED)return s;if(e===r.FLOORED)return Number(-1===this.sign())^Number(-1===n.sign())?s.add(n):s;if(e===r.EUCLIDEAN)return-1===s.sign()?s.add(-1===n.sign()?n.neg():n):s;throw new Error("Invalid ModType")}pow(t){const r=this.parseParameter(t);if(!r.isInteger())throw new Error("Unsupported parameter");const e=r.numerator/r.denominator,n=e<o?-e:e,i=new f(this.numerator**n,this.denominator**n);return e<o?i.inv():i}powm(t,r,e){const n=this.parseParameter(t);if(!n.isInteger())throw new Error("Unsupported parameter");let i=n.toNumber();const o=this.parseParameter(r);let a=this,c=new f(s,s);for(;0!==i;)i%2!=0&&(c=c.mul(a).mod(o,e)),a=a.pow(u).mod(o,e),i=Math.floor(i/2);return c}inv(){return new f(this.denominator,this.numerator)}floor(r){return this.denominator===s?new d(this.numerator):this.round(r,t.TO_NEGATIVE)}ceil(r){return this.denominator===s?new d(this.numerator):this.round(r,t.TO_POSITIVE)}trunc(r){return this.denominator===s?new d(this.numerator):this.round(r,t.TO_ZERO)}round(t,r){if(t=void 0===t?0:t,!Number.isSafeInteger(t)||t<0)throw new Error("Invalid value for decimals");const e=this.toFixedNumber(t+1);if(this.sub(e).isZero())return e.round(t,r);return new d(`${e.toFixed(t+1)}1`).round(t,r)}roundToDigits(t,r){if(!Number.isSafeInteger(t)||t<1)throw new Error("Invalid value for digits");if(this.isZero())return new d(o);let e=this.abs(),n=0;for(;e.gte(s);)e=e.div(l),n++;const i=new f(s,l);for(;e.lt(i);)e=e.mul(l),n--;let u=e.round(t,r);return u=u._incExponent(n),-1===this.sign()?u.neg():u}gcd(t,r){let e=t<o?-t:t,n=r<o?-r:r;if(n>e){const t=e;e=n,n=t}for(;;){if(n===o)return e;if(e%=n,e===o)return n;n%=e}}simplify(){let{numerator:t,denominator:r}=this;const e=this.gcd(t,r);return e>s&&(t/=e,r/=e),r<o&&(t=-t,r=-r),new f(t,r)}normalize(){const{numerator:r,denominator:e}=this.simplify();if(e===s)return new d(r,0);const n=new f(r,e),{cycleLen:i,cycleStart:o}=n.getDecimalFormat(0);return 0!==i?n:n.round(o,t.TO_ZERO)}getFractionParts(t=!0){const r=t?this.simplify():this;return{numerator:new d(r.numerator),denominator:new d(r.denominator)}}sign(){return(this.numerator<o?-1:1)*(this.denominator<o?-1:1)}abs(){return new f(this.numerator<o?-this.numerator:this.numerator,this.denominator<o?-this.denominator:this.denominator)}neg(){return this.mul(-s)}intPart(){return this.trunc()}fracPart(){return this.sub(this.trunc())}cmp(t){const r=this.parseParameter(t),e=this.denominator===r.denominator,n=e?this.numerator:this.numerator*r.denominator,i=e?r.numerator:r.numerator*this.denominator;return n===i?0:n>i?1:-1}eq(t){return 0===this.cmp(t)}lt(t){return-1===this.cmp(t)}lte(t){return this.cmp(t)<=0}gt(t){return 1===this.cmp(t)}gte(t){return this.cmp(t)>=0}clamp(t,r){const e=w(t),n=w(r);if(e.gt(n))throw new Error("Min parameter has to be smaller than max");return this.lt(e)?e:this.gt(n)?n:this}isZero(){return this.numerator===o}isOne(){return this.numerator===this.denominator}isInteger(){return this.numerator%this.denominator===o}serialize(){return[this.numerator,this.denominator]}toNumber(){return Number(this.toPrecision(20))}convertToFraction(){return this}getNumberForBitwiseOp(){if(!this.isInteger()||-1===this.sign())throw new Error("Only positive integers are supported");return this.intPart()}bitwiseAnd(t){return this.getNumberForBitwiseOp().bitwiseAnd(t)}bitwiseOr(t){return this.getNumberForBitwiseOp().bitwiseOr(t)}bitwiseXor(t){return this.getNumberForBitwiseOp().bitwiseXor(t)}shiftLeft(t){return this.getNumberForBitwiseOp().shiftLeft(t)}shiftRight(t){return this.getNumberForBitwiseOp().shiftRight(t)}getDecimalFormat(t){t=void 0===t?Number.MAX_SAFE_INTEGER:t;let r=this.denominator<o?-this.denominator:this.denominator,e=0;for(;r%u===o;)r/=u,e++;let n=0;for(;r%m===o;)r/=m,n++;const i=Math.max(e,n);if(r===s)return{cycleLen:0,cycleStart:i};const a=Math.max(1,t-i);let c=l%r,h=1;for(;c!==s;){if(h===a)return{cycleLen:null,cycleStart:i};c=c*l%r,h++}return{cycleLen:h,cycleStart:i}}toFixed(r,e=t.TO_ZERO,n=!1){if(!Number.isSafeInteger(r)||r<0)throw new Error("Invalid parameter");return this.round(r,e).toFixed(r,t.TO_ZERO,n)}toRepeatingParts(t){if(this.isZero())return["0","",""];const{cycleLen:r,cycleStart:n}=this.simplify().getDecimalFormat(t);if(null===r||0===r){const r=t??n,i=this.toFixed(r),o=e(i).split(".");return[o[0],o[1]??"",""]}const i=n+r,o=this.toFixed(i).split(".");return[o[0],o[1].slice(0,n),o[1].slice(n)]}toRepeatingDigits(t){const r=this.toRepeatingParts(t);let e=r[0];return(r[1]||r[2])&&(e+=`.${r[1]}`),r[2]&&(e+=`(${r[2]})`),e}toExponential(r,e=t.TO_ZERO,n=!1){if(!Number.isSafeInteger(r)||r<0)throw new Error("Invalid parameters");return this.toFixedNumber(r).toExponential(r,e,n)}toFraction(){const{numerator:t,denominator:r}=this.getFractionParts(!0);return`${t.toString()}/${r.toString()}`}toFixedNumber(t){const r=this.numerator*l**BigInt(t);return new d(r/this.denominator,t)}toBase(t,r){if(!Number.isSafeInteger(t)||t<2||t>16)throw new Error("Invalid radix");if(void 0!==r&&(!Number.isSafeInteger(r)||r<0))throw new Error("Invalid parameter");if(10===t)return void 0===r?this.toRepeatingDigits(r):e(this.toFixed(r));const n=this.normalize(),i=void 0===r?Number.MAX_SAFE_INTEGER:r+1;let o=n.intPart(),s=n.sub(o);const u=-1===n.sign();u&&(o=o.neg(),s=s.neg());const a=new Map;let c=[];for(;!s.isZero()&&c.length!==i;){const r=s.mul(t),e=r.normalize().toFraction(),n=a.get(e);if(void 0!==n){c=[...c.slice(0,n-1),"(",...c.slice(n-1),")"];break}const i=Math.abs(r.intPart().toNumber());c.push(i.toString(t)),s=r.fracPart(),a.set(e,c.length)}c.length===i&&c.pop();const m=c.join("");return`${u?"-":""}${o.toString(t)}${c.length?".":""}${m}`}toString(t,r){return void 0===t||10===t?this.toRepeatingDigits(r):this.toBase(t,r)}toPrecision(r,e=t.TO_ZERO,n=!1){if(!Number.isSafeInteger(r)||r<1)throw new Error("Invalid parameter");return this.roundToDigits(r,e).toPrecision(r,t.TO_ZERO,n)}valueOf(){throw new Error("Unsafe conversion to Number type! Use toNumber() instead.")}}function g(t){if(t instanceof d||t instanceof f)return t;if("bigint"==typeof t)return new d(t);if("number"==typeof t){if(!Number.isSafeInteger(t))throw new Error("Floating point values as numbers are unsafe. Please provide them as a string.");return new d(t)}if("string"==typeof t)return t.includes("/")||t.includes("(")?new f(t,s):new d(t);throw new Error("Unsupported parameter type")}const w=(t,r)=>{if(void 0===t)throw new Error("First parameter cannot be undefined");const e=g(t);if(void 0===r)return e;const n=g(r);return new f(e,s).div(new f(n,s))};w.min=(...t)=>{if(0===t.length)throw new Error("Got empty array");let r=w(t[0]);for(let e=1;e<t.length;e++){const n=w(t[e]);n.lt(r)&&(r=n)}return r},w.max=(...t)=>{if(0===t.length)throw new Error("Got empty array");let r=w(t[0]);for(let e=1;e<t.length;e++){const n=w(t[e]);n.gt(r)&&(r=n)}return r};const b=(t,r)=>{let e=o;for(let n=0;n<t.length;n++){const i=t.charAt(n),o=parseInt(i,r);if(Number.isNaN(o))throw new Error(`Invalid digit "${i}"`);e*=BigInt(r),e+=BigInt(o)}return e};w.fromBase=(t,r)=>{if("string"!=typeof t)throw new Error("First parameter must be string");if(!Number.isSafeInteger(r)||r<2||r>16)throw new Error("Invalid radix");if(10===r)return w(t);if(0===(t=t.trim()).length)throw new Error("Empty string is not allowed");const e=t.startsWith("-");e&&(t=t.slice(1));const n=t.match(/^([0-9a-f]*)(?:\.([0-9a-f]*)(?:\(([0-9a-f]+)\))?)?$/i);if(!n)throw new Error(`Cannot parse number "${t}"`);const i=n[1]??"",o=n[2]??"",u=n[3]??"";if(u.length>0){const t=b(`${i}${o}${u}`,r)-b(`${i}${o}`,r),n=b((r-1).toString(r).repeat(u.length)+"0".repeat(o.length),r),s=new f(t,n).normalize();return e?s.neg():s}const a=b(i,r),c=b(o,r),m=new f(c,BigInt(r)**BigInt(o.length)),l=new f(a,s).add(m).normalize();return e?l.neg():l},w.range=function*(t,r,e){const n=w(r),i=w(e??1);let o=w(t);for(;o.lt(n);)yield o,o=o.add(i)},w.gcd=(t,r)=>{const e=w(t).abs(),n=w(r).abs();let i=n.gt(e)?n:e,o=i.eq(e)?n:e;for(;;){if(o.isZero())return i;if(i=i.mod(o),i.isZero())return o;o=o.mod(i)}},w.lcm=(t,r)=>{const e=w(t).abs(),n=w(r).abs(),i=e.mul(n);if(i.isZero())throw new Error("LCM of zero is undefined");const o=w.gcd(e,n);return i.div(o)};const E=(t,r,e)=>{const n=((t,r)=>{let e=r.toNumber();if(Number.isFinite(e)){const r=e<0;r&&(e=-e);let n=e**(1/t);return r&&(n=-n),n.toString()}const n=r.abs().toFixed(0).length,i=Math.ceil(n/t);return`${1===r.sign()?"":"-"}5e${i}`})(t,r);let i=new d("0"!==n?n:"1");const o=new f(t-1,t),s=new f(r,t),u=BigInt(t-1);let a=i.trunc(e+5);for(;i=o.mul(i).add(s.mul(i.pow(u).inv())),i=i.trunc(e+5),!i.isZero()&&!a.eq(i);)a=i;return i.trunc(e)},p=(t,r,e)=>{if(!Number.isSafeInteger(t))throw new Error("Integer is expected for N");if(t<0)throw new Error("Negative N is not supported");if(0===t)throw new Error("N cannot be zero");const n=i(w(r),e);if(1===t)return n.trunc(e);if(t%2==0&&-1===n.sign())throw new Error("Complex numbers are not supported");if(n.isZero())return new d(o).trunc(e);if(n.isOne())return new d(s).trunc(e);return E(t,n,e)},I=(t,r)=>p(2,t,r),N=(t,r)=>p(3,t,r);class v{constructor(t,r){this.cachedDecimals=0,this.fn=t,this.max=r}get(t){if(t<=this.cachedDecimals)return this.cache.trunc(t);const r=new d(this.fn(t)),e=Math.min(this.max,t);return this.cachedDecimals!==e&&(this.cache=r.trunc(e),this.cachedDecimals=e),r}}const O=(t,r)=>{let e=i(w(t),r);if(e.isOne())return new d(0).trunc(r);if(e.lte(0))throw new Error("Invalid parameter");let n=0;const a=w("0.1");for(;e.sub(s).abs().gt(a);)e=new d(I(e,r+10)),n++;const c=function*(t,r){const e=t.pow(u).normalize();let n=t,i=s,o=w(t);for(;;){n=n.mul(e),i+=u;const t=n.div(i).trunc(r+10);o=o.add(t),yield{term:t,sum:o}}}(e.sub(s).div(e.add(s)),r);for(const{term:t,sum:e}of c)if(t.isZero()){return e.mul(u**BigInt(n+1)).trunc(r)}return w(o)},T=(t,r,e)=>{if(!Number.isSafeInteger(t)||t<2)throw new Error("Invalid parameter for N");const n=O(r,e+10),i=O(t,e+10);return new d(n).div(i).trunc(e)},P=new v((t=>O(u,t)),200),_=(t,r)=>new d(O(t,r+10)).div(P.get(r+10)).trunc(r),S=new v((t=>O(l,t)),200),R=(t,r)=>new d(O(t,r+10)).div(S.get(r+10)).trunc(r);const A=(t,r)=>{const e=i(w(t),r),n=w(`1e-${r+5}`),a=function*(t,r){let e=t.add(1),n=BigInt(6),i=c;const o=t.pow(u);let a=o;for(;;){const c=a.mul(t.add(i-s)).div(n);n*=i*(i+s),i+=u,a=a.mul(o),e=e.add(c).trunc(r+5),yield{term:c,sum:e}}}(e,r);for(const{term:t,sum:e}of a)if(t.abs().lt(n))return e.trunc(r);return w(o)},F=(t,r,e)=>{const n=i(w(t),e),o=i(w(r),e);if(o.isInteger()&&Number.isSafeInteger(o.toNumber()))return n.pow(o).trunc(e);if(-1===n.sign()&&!o.isInteger())throw new Error("Complex numbers are not supported");const s=O(n,e+5),u=o.mul(s);return A(u,e+5).trunc(e)},y=new v((t=>{if(0===t)return w(a);let r=s,e=a*l**BigInt(t+20),n=e;for(;e!==o;)e=e*r/((r+s)*c),r+=u,n+=e/r;return w(`3.${n.toString().slice(1,t+1)}`)}),1e3),B=t=>0===t?w(a):y.get(t).trunc(t),Z=(r,e)=>{let n=r.round(e+5,t.NEAREST_AWAY_FROM_ZERO);const i=B(e+5),o=((t,r,e)=>{const n=Math.max(3,e),i=t.trunc(n),o=i.div(r).round();return r.mul(o).trunc(n).eq(i)?o:null})(n,i.div(12),e);if(null!==o)return(t=>{let r=t.mod(h).toNumber();r<0&&(r+=24);const e=Math.floor(r/6)+1;let n=15*r;return 4===e?n=360-n:3===e?n-=180:2===e&&(n=180-n),{specialCaseDeg:n,quadrant:e,subHalfPiAngle:null}})(o);const s=i.mul(u);n=n.mod(s),-1===n.sign()&&(n=n.add(s));const a=n.mul(u).div(i).floor().toNumber()+1;let c=n;return 4===a?c=s.sub(c):3===a?c=c.sub(i):2===a&&(c=i.sub(c)),{specialCaseDeg:null,quadrant:a,subHalfPiAngle:c}};const $=(t,r,e)=>{let n=w(t);return r&&(n=n.neg()),n.trunc(e)},x=(t,r,e)=>{let n;if(0===t)n=s;else if(30===t)n=w(I(a,e+5)).div(u);else if(45===t)n=w(I(u,e+5)).div(u);else if(60===t)n="0.5";else{if(90!==t)throw new Error;n=o}return $(n,r,e)},D=(r,e)=>{const n=e+10,o=i(w(r),e+5),{specialCaseDeg:c,subHalfPiAngle:m,quadrant:l}=Z(o,e),h=2===l||3===l;if(null!==c)return x(c,h,e);const d=w(`1e-${n}`),f=function*(r,e){const n=r.round(e+10,t.NEAREST_AWAY_FROM_ZERO).pow(u);let i=n,o=u,c=w(s).sub(i.div(o).trunc(e+10)),m=a;for(;;){o*=m*(m+s),m+=u;const t=m*(m+s);m+=u,i=i.mul(n),o*=t;let r=i.mul(t);i=i.mul(n),r=r.sub(i);const a=r.div(o).trunc(e+10);c=c.add(a),yield{term:a,sum:c}}}(m,e);for(const{term:t,sum:r}of f)if(t.lt(d))return $(r,h,e);return w(0)},M=(t,r)=>{const e=i(w(t),r+5),{specialCaseDeg:n,quadrant:o}=Z(e,r);if(null!==n)return x(90-n,3===o||4===o,r);const s=new d(B(r+5));return D(s.div(u).sub(e),r+5).trunc(r)},z=(t,r)=>{const e=i(w(t),r+5),{specialCaseDeg:n,quadrant:o,subHalfPiAngle:c}=Z(e,r),m=2===o||4===o;if(null!==n){if(0===n)return $("0",m,r);if(30===n)return $(w(s).div(I(a,r+5)),m,r);if(45===n)return $("1",m,r);if(60===n)return $(I(a,r+5),m,r);if(90===n)throw new Error("Out of range");throw new Error}const l=w(D(c.mul(u),r+5)),h=w(s).sub(l).div(w(s).add(l)).round(r+5),d=I(h,r+5).trunc(r);return m?d.neg():d};const U=(t,r)=>{let e=i(w(t),r);if(e.isZero())return w(0);if(e.abs().isOne())return w(B(r)).div(4*e.sign()).trunc(r);let n=0;const o=w("0.42");for(;e.abs().gt(o);){const t=w(I(e.pow(u).add(s),r+10));e=e.div(t.add(s)),n++}const c=w(`1e-${r+10}`),m=function*(t,r){const e=t.pow(u).normalize(),n=e.pow(u).normalize();let i=a,o=t.sub(t.mul(e).div(i)),s=t.mul(n);for(;;){i+=u;const t=i+u,a=s.mul(e.mul(-i).add(t)).div(i*t);i=t,s=s.mul(n),o=o.add(a).trunc(r+10),yield{term:a,sum:o}}}(e,r);for(const{term:t,sum:e}of m)if(t.abs().lt(c)){return e.mul(u**BigInt(n)).trunc(r)}return w(0)},C=(t,r)=>{const e=i(w(t),r);if(e.isZero())return w(o);if(e.abs().isOne())return w(B(r)).mul(e.sign()).div(u).trunc(r);if(e.abs().eq("1/2"))return w(B(r)).mul(e.sign()).div(6).trunc(r);if(e.gt(s)||e.lt(-s))throw new Error("Out of range");const n=w(I(e.pow(u).neg().add(s),r+10));return w(U(e.div(n.add(s)),r+10)).mul(u).trunc(r)},V=(t,r)=>{const e=i(w(t),r);if(e.isZero())return w(B(r)).div(u).trunc(r);if(e.isOne())return w(o);if(e.abs().isOne())return B(r);if(e.abs().eq("1/2")){const t=w(B(r)).div(a);return-1===e.sign()?t.mul(u).trunc(r):t.trunc(r)}if(e.gt(s)||e.lt(-s))throw new Error("Out of range");return w(B(r+10)).div(u).sub(C(e,r+10)).trunc(r)};const L=(t,r)=>{const e=i(w(t),r),n=new d(`1e-${r+5}`),a=function*(t,r){let e=t,n=s;const i=t.pow(u).normalize();let o=t.trunc(r+5),a=u;for(;;){e=e.mul(i),n*=a*(a+s),a+=u;const t=e.div(n);o=o.add(t).trunc(r+5),yield{term:t,sum:o}}}(e,r);for(const{term:t,sum:e}of a)if(t.abs().lt(n))return e.trunc(r);return w(o)};const G=(t,r)=>{const e=i(w(t),r),n=new d(`1e-${r+5}`),c=function*(t,r){const e=t.pow(u).normalize();let n=e,i=u,o=n.div(i).add(s).trunc(r+5),c=a;for(;;){n=n.mul(e),i*=c*(c+s),c+=u;const t=n.div(i);o=o.add(t).trunc(r+5),yield{term:t,sum:o}}}(e,r);for(const{term:t,sum:e}of c)if(t.abs().lt(n))return e.trunc(r);return w(o)},W=(t,r)=>{const e=i(w(t),r);if(e.isZero())return w(o);const n=G(e,r+10).abs();return I(n.pow(u).sub(s),r+10).div(n).mul(e.sign()).trunc(r)},q=(t,r)=>{const e=i(w(t),r);if(e.isZero())return w(o);const n=I(e.pow(u).add(s),r+5);return O(e.add(n),r+5).trunc(r)},Y=(t,r)=>{const e=i(w(t),r);if(e.isOne())return w(o);if(e.lt(s))throw new Error("Out of range");const n=I(e.pow(u).sub(s),r+5);return O(e.add(n),r+5).trunc(r)},X=(t,r)=>{const e=i(w(t),r);if(e.abs().gte(s))throw new Error("Out of range");if(e.isZero())return w(o);const n=O(e.add(s).div(e.neg().add(s)),r+5);return w(n).div(u).trunc(r)};export{w as ExactNumber,r as ModType,B as PI,t as RoundingMode,V as acos,Y as acosh,C as asin,q as asinh,U as atan,X as atanh,N as cbrt,D as cos,G as cosh,A as exp,O as log,R as log10,_ as log2,T as logn,p as nthroot,F as pow,M as sin,L as sinh,I as sqrt,z as tan,W as tanh};
