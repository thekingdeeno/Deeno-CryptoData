/*!
 * exactnumber v1.0.1 (https://www.npmjs.com/package/exactnumber)
 * (c) Dani Biro
 * @license MIT
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.exactnumber = {}));
})(this, (function (exports) { 'use strict';

    // a random, hard to guess number
    const ROUNDING_MODE_BASE = 201000;
    exports.RoundingMode = void 0;
    (function (RoundingMode) {
        /** Rounds to nearest number, with ties rounded towards +Infinity. Similar to Math.round(). */
        RoundingMode[RoundingMode["NEAREST_TO_POSITIVE"] = ROUNDING_MODE_BASE + 8] = "NEAREST_TO_POSITIVE";
        /** Rounds to nearest number, with ties rounded towards -Infinity. */
        RoundingMode[RoundingMode["NEAREST_TO_NEGATIVE"] = ROUNDING_MODE_BASE + 9] = "NEAREST_TO_NEGATIVE";
        /** Rounds to nearest number, with ties rounded towards the nearest even number. */
        RoundingMode[RoundingMode["NEAREST_TO_EVEN"] = ROUNDING_MODE_BASE + 10] = "NEAREST_TO_EVEN";
        /** Rounds to nearest number, with ties rounded towards zero. */
        RoundingMode[RoundingMode["NEAREST_TO_ZERO"] = ROUNDING_MODE_BASE + 11] = "NEAREST_TO_ZERO";
        /** Rounds to nearest number, with ties rounded away from zero. */
        RoundingMode[RoundingMode["NEAREST_AWAY_FROM_ZERO"] = ROUNDING_MODE_BASE + 12] = "NEAREST_AWAY_FROM_ZERO";
        /** Rounds towards +Infinity. Similar to Math.ceil(). */
        RoundingMode[RoundingMode["TO_POSITIVE"] = ROUNDING_MODE_BASE + 1] = "TO_POSITIVE";
        /** Rounds towards -Infinity. Similar to Math.floor(). */
        RoundingMode[RoundingMode["TO_NEGATIVE"] = ROUNDING_MODE_BASE + 2] = "TO_NEGATIVE";
        /** Rounds towards zero. Similar to Math.trunc(). */
        RoundingMode[RoundingMode["TO_ZERO"] = ROUNDING_MODE_BASE + 3] = "TO_ZERO";
        /** Rounds away from zero */
        RoundingMode[RoundingMode["AWAY_FROM_ZERO"] = ROUNDING_MODE_BASE + 4] = "AWAY_FROM_ZERO";
    })(exports.RoundingMode || (exports.RoundingMode = {}));
    exports.ModType = void 0;
    (function (ModType) {
        ModType["TRUNCATED"] = "T";
        ModType["FLOORED"] = "F";
        ModType["EUCLIDEAN"] = "E";
    })(exports.ModType || (exports.ModType = {}));

    /* eslint-disable @typescript-eslint/naming-convention */
    /** Trims trailing zeros from numbers in fixed-point format (1.23000 -> 1.23) */
    const trimTrailingZerosFromFixed = (num) => {
        const pointPos = num.indexOf('.');
        if (pointPos === -1)
            return num;
        let firstZeroAt = num.length;
        while (firstZeroAt > pointPos && num.charAt(firstZeroAt - 1) === '0')
            firstZeroAt--;
        const newLength = pointPos === firstZeroAt - 1 ? pointPos : firstZeroAt;
        if (newLength === 0)
            return '0';
        return num.slice(0, newLength);
    };
    const bigIntToStr = (num, inputDecimals, outputDecimals, trimZeros) => {
        let str = num.toString();
        if (inputDecimals === 0 && outputDecimals === 0)
            return str;
        const isNegative = str.startsWith('-');
        if (isNegative) {
            str = str.slice(1);
        }
        if (inputDecimals >= str.length) {
            str = '0'.repeat(inputDecimals - str.length + 1) + str;
        }
        if (inputDecimals > 0) {
            const wholePart = str.slice(0, -inputDecimals);
            const fracPart = str.slice(-inputDecimals);
            const outFracPart = outputDecimals <= inputDecimals
                ? fracPart.slice(0, outputDecimals)
                : `${fracPart}${'0'.repeat(outputDecimals - inputDecimals)}`;
            if (outFracPart.length !== 0) {
                str = `${wholePart}.${outFracPart}`;
                if (trimZeros) {
                    str = trimTrailingZerosFromFixed(str);
                }
            }
            else {
                str = wholePart;
            }
        }
        else if (outputDecimals > 0 && !trimZeros) {
            str = `${str}.${'0'.repeat(outputDecimals)}`;
        }
        return isNegative ? `-${str}` : str;
    };
    // used by the approximation functions to limit input precision (speed optimization)
    const limitDecimals = (x, decimals) => {
        x = x.normalize();
        if (x instanceof FixedNumber) {
            return x.round(decimals, exports.RoundingMode.NEAREST_AWAY_FROM_ZERO);
        }
        return x;
    };
    // BigInt literals (1n) are not supported by all parsers
    // also, the BigInt() constructor is still too slow to call in a loop
    const _0N = BigInt(0);
    const _1N = BigInt(1);
    const _2N = BigInt(2);
    const _3N = BigInt(3);
    const _4N = BigInt(4);
    const _5N = BigInt(5);
    const _10N = BigInt(10);
    const _24N = BigInt(24);

    class FixedNumber {
        constructor(x, decimalPos = 0) {
            this.type = 'fixed';
            // fast path
            if (typeof x === 'bigint') {
                this.number = x;
                this.decimalPos = decimalPos;
            }
            else {
                const input = this.parseConstructorParameter(x);
                this.number = input.number;
                this.decimalPos = input.decimalPos;
            }
        }
        parseConstructorParameter(x) {
            if (x instanceof FixedNumber) {
                return { number: x.number, decimalPos: x.decimalPos };
            }
            if (x instanceof Fraction) {
                if (!x.isInteger()) {
                    throw new Error('Cannot create FixedNumber from non-integer Fraction');
                }
                return { number: x.trunc().number, decimalPos: 0 };
            }
            if (typeof x === 'number') {
                if (!Number.isSafeInteger(x)) {
                    throw new Error('The specified number cannot be exactly represented as an integer. Please provide a string instead.');
                }
                return { number: BigInt(x), decimalPos: 0 };
            }
            if (typeof x === 'string') {
                x = x.trim();
                if (x.length === 0)
                    throw new Error('Empty string is not allowed');
                const m = x.match(/^(-?[0-9]*)(?:\.([0-9]*))?(?:[eE]([+-]?[0-9]+))?$/);
                if (!m) {
                    throw new Error(`Cannot parse number "${x}"`);
                }
                let decimalPos = 0; // at the right end
                let str = m[1] ?? '0';
                if (m[2] !== undefined) {
                    str += m[2];
                    decimalPos += m[2].length;
                }
                if (m[3] !== undefined) {
                    const exp = Number(m[3]);
                    if (exp > 0) {
                        str += '0'.repeat(exp);
                    }
                    else {
                        decimalPos -= exp;
                    }
                }
                return { number: BigInt(str), decimalPos };
            }
            throw new Error('Unsupported parameter!');
        }
        scaleNumber(number, decimalPos) {
            const maxPos = Math.max(this.decimalPos, decimalPos);
            const a = maxPos === this.decimalPos ? this.number : this.number * _10N ** BigInt(maxPos - this.decimalPos);
            const b = maxPos === decimalPos ? number : number * _10N ** BigInt(maxPos - decimalPos);
            return { a, b, decimalPos: maxPos };
        }
        add(x) {
            const operand = parseParameter(x);
            if (operand instanceof Fraction) {
                return operand.add(this);
            }
            const fixedOperand = operand;
            const { a, b, decimalPos: newPos } = this.scaleNumber(fixedOperand.number, fixedOperand.decimalPos);
            const res = new FixedNumber(a + b, newPos);
            return res;
        }
        sub(x) {
            const operand = parseParameter(x);
            return this.add(operand.neg());
        }
        mul(x) {
            const operand = parseParameter(x);
            if (operand instanceof Fraction) {
                return operand.mul(this);
            }
            const fixedOperand = operand;
            const product = this.number * fixedOperand.number;
            const res = new FixedNumber(product, this.decimalPos + fixedOperand.decimalPos);
            return res;
        }
        pow(x) {
            const operand = parseParameter(x);
            const exp = operand.toNumber();
            if (!Number.isSafeInteger(exp)) {
                throw new Error('Unsupported parameter');
            }
            const absExp = Math.abs(exp);
            const res = new FixedNumber(this.number ** BigInt(absExp), this.decimalPos * absExp);
            return exp < 0 ? res.inv() : res;
        }
        powm(_exp, _mod, modType) {
            let exp = parseParameter(_exp).toNumber();
            if (!Number.isSafeInteger(exp)) {
                throw new Error('Unsupported parameter');
            }
            const mod = parseParameter(_mod);
            let base = this;
            let res = new FixedNumber(_1N);
            while (exp !== 0) {
                if (exp % 2 !== 0) {
                    res = res.mul(base).mod(mod, modType);
                }
                base = base.pow(_2N).mod(mod, modType);
                exp = Math.floor(exp / 2);
            }
            return res;
        }
        div(x) {
            const frac = this.convertToFraction();
            return frac.div(x);
        }
        divToInt(x) {
            const operand = parseParameter(x);
            if (operand instanceof Fraction) {
                return this.convertToFraction().divToInt(operand);
            }
            const fixedOperand = operand;
            const { a, b } = this.scaleNumber(fixedOperand.number, fixedOperand.decimalPos);
            const res = new FixedNumber(a / b);
            return res;
        }
        mod(x, type = exports.ModType.TRUNCATED) {
            const operand = parseParameter(x);
            if (operand instanceof Fraction) {
                return this.convertToFraction().mod(operand);
            }
            const fixedOperand = operand;
            const { a, b, decimalPos } = this.scaleNumber(fixedOperand.number, fixedOperand.decimalPos);
            const mod = a % b;
            const res = new FixedNumber(mod, decimalPos);
            if (type === exports.ModType.TRUNCATED) {
                return res;
            }
            if (type === exports.ModType.FLOORED) {
                return Number(a < _0N) ^ Number(b < _0N) ? res.add(b) : res;
            }
            if (type === exports.ModType.EUCLIDEAN) {
                return mod < _0N ? res.add(b < _0N ? -b : b) : res;
            }
            throw new Error('Invalid ModType');
        }
        abs() {
            const res = new FixedNumber(this.number < _0N ? -this.number : this.number, this.decimalPos);
            return res;
        }
        neg() {
            return this.mul(-_1N);
        }
        inv() {
            return this.convertToFraction().inv();
        }
        floor(decimals) {
            if (this.decimalPos === 0)
                return this;
            return this.round(decimals, exports.RoundingMode.TO_NEGATIVE);
        }
        ceil(decimals) {
            if (this.decimalPos === 0)
                return this;
            return this.round(decimals, exports.RoundingMode.TO_POSITIVE);
        }
        trunc(decimals) {
            if (this.decimalPos === 0)
                return this;
            return this.round(decimals, exports.RoundingMode.TO_ZERO);
        }
        isTieStr(lastDigitsStr) {
            if (lastDigitsStr[0] !== '5')
                return false;
            for (let i = 1; i < lastDigitsStr.length; i++) {
                if (lastDigitsStr[i] !== '0') {
                    return false;
                }
            }
            return true;
        }
        _round(decimals, roundingMode) {
            const shift = this.decimalPos - decimals;
            if (shift <= 0) {
                return this;
            }
            const exp = _10N ** BigInt(shift);
            const outDigits = this.number / exp;
            if (roundingMode === exports.RoundingMode.TO_ZERO) {
                return new FixedNumber(outDigits, decimals);
            }
            const extraDigits = this.number % exp;
            if (extraDigits === _0N) {
                return new FixedNumber(outDigits, decimals);
            }
            if (roundingMode === exports.RoundingMode.AWAY_FROM_ZERO) {
                const res = this.number < _0N ? outDigits - _1N : outDigits + _1N;
                return new FixedNumber(res, decimals);
            }
            if (roundingMode === exports.RoundingMode.TO_POSITIVE) {
                const res = this.number < _0N ? outDigits : outDigits + _1N;
                return new FixedNumber(res, decimals);
            }
            if (roundingMode === exports.RoundingMode.TO_NEGATIVE) {
                const res = this.number >= _0N ? outDigits : outDigits - _1N;
                return new FixedNumber(res, decimals);
            }
            if (![
                undefined,
                exports.RoundingMode.NEAREST_TO_ZERO,
                exports.RoundingMode.NEAREST_AWAY_FROM_ZERO,
                exports.RoundingMode.NEAREST_TO_POSITIVE,
                exports.RoundingMode.NEAREST_TO_NEGATIVE,
                exports.RoundingMode.NEAREST_TO_EVEN,
            ].includes(roundingMode)) {
                throw new Error('Invalid rounding mode. Use the predefined values from the RoundingMode enum.');
            }
            let extraDigitsStr = (extraDigits < _0N ? -extraDigits : extraDigits).toString();
            // '00123' extra part will appear in extraDigitsStr as '123'
            // -> in this case we can exclude the tie case by setting the extra part to zero
            if (extraDigitsStr.length < shift) {
                extraDigitsStr = '0';
            }
            if (this.isTieStr(extraDigitsStr)) {
                if (roundingMode === exports.RoundingMode.NEAREST_TO_ZERO) {
                    return new FixedNumber(outDigits, decimals);
                }
                if (roundingMode === exports.RoundingMode.NEAREST_AWAY_FROM_ZERO) {
                    const res = this.number < _0N ? outDigits - _1N : outDigits + _1N;
                    return new FixedNumber(res, decimals);
                }
                if (roundingMode === undefined || roundingMode === exports.RoundingMode.NEAREST_TO_POSITIVE) {
                    const res = this.number < _0N ? outDigits : outDigits + _1N;
                    return new FixedNumber(res, decimals);
                }
                if (roundingMode === exports.RoundingMode.NEAREST_TO_NEGATIVE) {
                    const res = this.number >= _0N ? outDigits : outDigits - _1N;
                    return new FixedNumber(res, decimals);
                }
                if (roundingMode === exports.RoundingMode.NEAREST_TO_EVEN) {
                    if (outDigits % _2N === _0N) {
                        return new FixedNumber(outDigits, decimals);
                    }
                    const res = outDigits < _0N ? outDigits - _1N : outDigits + _1N;
                    return new FixedNumber(res, decimals);
                }
            }
            if (Number(extraDigitsStr[0]) < 5) {
                return new FixedNumber(outDigits, decimals);
            }
            const res = this.number < _0N ? outDigits - _1N : outDigits + _1N;
            return new FixedNumber(res, decimals);
        }
        round(decimals, roundingMode) {
            decimals = decimals === undefined ? 0 : decimals;
            if (!Number.isSafeInteger(decimals) || decimals < 0) {
                throw new Error('Invalid value for decimals');
            }
            return this._round(decimals, roundingMode).normalize();
        }
        _incExponent(amount) {
            if (amount === 0)
                return this;
            let newNumber = this.number;
            let newDecimalPos = this.decimalPos;
            if (amount < 0) {
                newDecimalPos -= amount;
            }
            else {
                // amount >= 0
                const maxChange = Math.min(amount, this.decimalPos);
                newDecimalPos -= maxChange;
                const rem = amount - maxChange;
                if (rem > 0) {
                    newNumber *= _10N ** BigInt(rem);
                }
            }
            return new FixedNumber(newNumber, newDecimalPos);
        }
        countDigits() {
            if (this.number === _0N)
                return 1;
            let digits = 0;
            let x = this.number < _0N ? -this.number : this.number;
            while (x > _0N) {
                x /= _10N;
                digits++;
            }
            return digits;
        }
        // move the number to the +-[0.1, 1) interval
        toSubZeroNum() {
            const digits = this.countDigits();
            const subZeroNum = new FixedNumber(this.number, digits);
            const exponentDiff = digits - this.decimalPos;
            return { subZeroNum, exponentDiff };
        }
        roundToDigits(digits, roundingMode) {
            if (!Number.isSafeInteger(digits) || digits < 1) {
                throw new Error('Invalid value for digits');
            }
            const { subZeroNum, exponentDiff } = this.toSubZeroNum();
            let roundedNumber = subZeroNum.round(digits, roundingMode);
            roundedNumber = roundedNumber._incExponent(exponentDiff);
            return roundedNumber;
        }
        intPart() {
            return this.trunc();
        }
        fracPart() {
            return this.sub(this.trunc());
        }
        sign() {
            return this.number < _0N ? -1 : 1;
        }
        bitwiseAnd(x) {
            x = ExactNumber(x);
            if (!this.isInteger() || this.sign() === -1 || !x.isInteger() || x.sign() === -1) {
                throw new Error('Only positive integers are supported');
            }
            if (x instanceof Fraction) {
                x = x.trunc();
            }
            const pow = _2N ** _24N;
            let an = this.normalize().number;
            let bn = x.trunc().normalize().number;
            let res = _0N;
            let shift = _1N;
            while (an > _0N && bn > _0N) {
                const modA = BigInt.asUintN(24, an);
                const modB = BigInt.asUintN(24, bn);
                res += BigInt(Number(modA) & Number(modB)) * shift;
                shift *= pow;
                an /= pow;
                bn /= pow;
            }
            return new FixedNumber(res);
        }
        bitwiseOr(x) {
            x = ExactNumber(x);
            if (!this.isInteger() || this.sign() === -1 || !x.isInteger() || x.sign() === -1) {
                throw new Error('Only positive integers are supported');
            }
            if (x instanceof Fraction) {
                x = x.trunc();
            }
            const pow = _2N ** _24N;
            let an = this.normalize().number;
            let bn = x.trunc().normalize().number;
            let res = _0N;
            let shift = _1N;
            while (an > _0N || bn > _0N) {
                const modA = BigInt.asUintN(24, an);
                const modB = BigInt.asUintN(24, bn);
                res += BigInt(Number(modA) | Number(modB)) * shift;
                shift *= pow;
                an /= pow;
                bn /= pow;
            }
            return new FixedNumber(res);
        }
        bitwiseXor(x) {
            x = ExactNumber(x);
            if (!this.isInteger() || this.sign() === -1 || !x.isInteger() || x.sign() === -1) {
                throw new Error('Only positive integers are supported');
            }
            if (x instanceof Fraction) {
                x = x.trunc();
            }
            const pow = _2N ** _24N;
            let an = this.normalize().number;
            let bn = x.trunc().normalize().number;
            let res = _0N;
            let shift = _1N;
            while (an > _0N || bn > _0N) {
                const modA = BigInt.asUintN(24, an);
                const modB = BigInt.asUintN(24, bn);
                res += BigInt(Number(modA) ^ Number(modB)) * shift;
                shift *= pow;
                an /= pow;
                bn /= pow;
            }
            return new FixedNumber(res);
        }
        shiftLeft(bitCount) {
            if (!this.isInteger() || this.sign() === -1) {
                throw new Error('Only positive integers are supported');
            }
            if (!Number.isSafeInteger(bitCount) || bitCount < 0) {
                throw new Error('Invalid value for bitCount');
            }
            const pow = _2N ** BigInt(bitCount);
            return this.mul(pow);
        }
        shiftRight(bitCount) {
            if (!this.isInteger() || this.sign() === -1) {
                throw new Error('Only positive integers are supported');
            }
            if (!Number.isSafeInteger(bitCount) || bitCount < 0) {
                throw new Error('Invalid value for bitCount');
            }
            const pow = _2N ** BigInt(bitCount);
            return new FixedNumber(this.normalize().number / pow);
        }
        cmp(x) {
            const operand = parseParameter(x);
            if (operand instanceof Fraction) {
                return -operand.cmp(this);
            }
            const fixedOperand = operand;
            const { a, b } = this.scaleNumber(fixedOperand.number, fixedOperand.decimalPos);
            if (a === b)
                return 0;
            return a > b ? 1 : -1;
        }
        eq(x) {
            return this.cmp(x) === 0;
        }
        lt(x) {
            return this.cmp(x) === -1;
        }
        lte(x) {
            return this.cmp(x) <= 0;
        }
        gt(x) {
            return this.cmp(x) === 1;
        }
        gte(x) {
            return this.cmp(x) >= 0;
        }
        clamp(min, max) {
            const minNum = ExactNumber(min);
            const maxNum = ExactNumber(max);
            if (minNum.gt(maxNum))
                throw new Error('Min parameter has to be smaller than max');
            if (this.lt(minNum))
                return minNum;
            if (this.gt(maxNum))
                return maxNum;
            return this;
        }
        isZero() {
            return this.number === _0N;
        }
        isOne() {
            if (this.decimalPos === 0) {
                return this.number === _1N;
            }
            const exp = _10N ** BigInt(this.decimalPos);
            const q = this.number / exp;
            return q === _1N && q * exp === this.number;
        }
        isInteger() {
            if (this.decimalPos === 0)
                return true;
            return this.number % _10N ** BigInt(this.decimalPos) === _0N;
        }
        serialize() {
            return [this.number, this.decimalPos];
        }
        getFractionParts(normalize = true) {
            return this.convertToFraction().getFractionParts(normalize);
        }
        normalize() {
            if (this.decimalPos === 0)
                return this;
            let pos = this.decimalPos;
            let n = this.number;
            while (pos > 0 && n % _10N === _0N) {
                pos--;
                n /= _10N;
            }
            return new FixedNumber(n, pos);
        }
        convertToFraction() {
            if (this.decimalPos === 0) {
                return new Fraction(this.number, _1N);
            }
            const denominator = _10N ** BigInt(this.decimalPos);
            return new Fraction(this.number, denominator);
        }
        toNumber() {
            return Number(this.toPrecision(20));
        }
        toFixed(decimals, roundingMode = exports.RoundingMode.TO_ZERO, trimZeros = false) {
            if (!Number.isSafeInteger(decimals) || decimals < 0)
                throw new Error('Invalid parameter');
            const rounded = this._round(decimals, roundingMode);
            return bigIntToStr(rounded.number, rounded.decimalPos, decimals, trimZeros);
        }
        toExponential(digits, roundingMode = exports.RoundingMode.TO_ZERO, trimZeros = false) {
            if (!Number.isSafeInteger(digits) || digits < 0)
                throw new Error('Invalid parameter');
            const rounded = this.roundToDigits(digits + 1, roundingMode).normalize();
            const isNegative = rounded.sign() === -1;
            const absNumber = rounded.abs();
            const str = absNumber.number.toString();
            const slicedString = str.length <= digits ? `${str}${'0'.repeat(digits - str.length + 1)}` : str.slice(0, digits + 1);
            let strWithPoint = slicedString;
            if (slicedString.length > 1) {
                strWithPoint = `${slicedString.slice(0, 1)}.${slicedString.slice(1)}`;
                if (trimZeros) {
                    strWithPoint = trimTrailingZerosFromFixed(strWithPoint);
                }
            }
            const fractionalDigitsBefore = absNumber.decimalPos;
            const fractionalDigitsAfter = str.length - 1;
            const exponent = fractionalDigitsAfter - fractionalDigitsBefore;
            const res = `${isNegative ? '-' : ''}${strWithPoint}e${exponent >= 0 ? '+' : ''}${exponent}`;
            return res;
        }
        toBase(radix, maxDigits) {
            if (!Number.isSafeInteger(radix) || radix < 2 || radix > 16)
                throw new Error('Invalid radix');
            if (maxDigits !== undefined && (!Number.isSafeInteger(maxDigits) || maxDigits < 0)) {
                throw new Error('Invalid parameter');
            }
            const num = this.normalize();
            if (num.decimalPos === 0)
                return num.number.toString(radix);
            const loopEnd = maxDigits === undefined ? Number.MAX_SAFE_INTEGER : maxDigits;
            let intPart = num.intPart();
            let fracPart = num.sub(intPart);
            const isNegative = num.sign() === -1;
            if (isNegative) {
                intPart = intPart.neg();
                fracPart = fracPart.neg();
            }
            const match = new Map();
            let digits = [];
            while (!fracPart.isZero()) {
                const mul = fracPart.mul(radix);
                const mulStr = mul.toString();
                const cycleStart = match.get(mulStr);
                if (cycleStart !== undefined) {
                    digits = [...digits.slice(0, cycleStart - 1), '(', ...digits.slice(cycleStart - 1), ')'];
                    break;
                }
                if (digits.length === loopEnd) {
                    break;
                }
                const q = Math.abs(mul.intPart().toNumber());
                digits.push(q.toString(radix));
                fracPart = mul.fracPart();
                match.set(mulStr, digits.length);
            }
            const digitsStr = digits.join('');
            const res = `${isNegative ? '-' : ''}${intPart.number.toString(radix)}${digits.length ? '.' : ''}${digitsStr}`;
            return res;
        }
        toFraction() {
            return this.convertToFraction().toFraction();
        }
        toString(radix, maxDigits) {
            if (radix === undefined || radix === 10) {
                const num = maxDigits !== undefined ? this.trunc(maxDigits) : this;
                return bigIntToStr(num.number, num.decimalPos, num.decimalPos, true);
            }
            return this.toBase(radix, maxDigits);
        }
        toPrecision(digits, roundingMode = exports.RoundingMode.TO_ZERO, trimZeros = false) {
            if (!Number.isSafeInteger(digits) || digits < 1)
                throw new Error('Invalid parameter');
            const rounded = this.roundToDigits(digits, roundingMode);
            const { subZeroNum, exponentDiff } = rounded.toSubZeroNum();
            const isNegative = subZeroNum.sign() === -1;
            let subZeroStr = bigIntToStr(subZeroNum.number, subZeroNum.decimalPos, subZeroNum.decimalPos, false);
            subZeroStr = subZeroStr.slice(isNegative ? 3 : 2); // '-0.' or '0.'
            // cut extra digits
            subZeroStr = subZeroStr.slice(0, Math.max(digits, exponentDiff));
            const whole = subZeroStr.slice(0, Math.max(0, exponentDiff));
            const frac = subZeroStr.slice(Math.max(0, exponentDiff));
            const suffixLength = Math.max(0, digits - whole.length - frac.length);
            const prefix = '0'.repeat(exponentDiff < 0 ? -exponentDiff : 0);
            let res = whole || '0';
            if (frac.length + prefix.length + suffixLength > 0) {
                const suffix = '0'.repeat(suffixLength);
                res += `.${prefix}${frac}${suffix}`;
                if (trimZeros) {
                    res = trimTrailingZerosFromFixed(res);
                }
            }
            return isNegative ? `-${res}` : res;
        }
        valueOf() {
            throw new Error('Unsafe conversion to Number type! Use toNumber() instead.');
        }
    }

    class Fraction {
        constructor(x, y) {
            this.type = 'fraction';
            // fast path
            if (typeof x === 'bigint' && typeof y === 'bigint') {
                this.numerator = x;
                this.denominator = y;
            }
            else {
                const xFraction = this.parseParameter(x);
                const yFraction = this.parseParameter(y);
                const res = xFraction.div(yFraction);
                const frac = res instanceof FixedNumber ? res.convertToFraction() : res;
                this.numerator = frac.numerator;
                this.denominator = frac.denominator;
            }
            if (this.denominator === _0N) {
                throw new Error('Division by zero');
            }
        }
        parseRepeatingDecimal(x) {
            if (!x.includes('(')) {
                return new FixedNumber(x).convertToFraction();
            }
            x = x.trim();
            const m = x.match(/^(-?[0-9]*)\.([0-9]+)?\(([0-9]+)\)(?:[eE]([+-]?[0-9]+))?$/);
            if (!m) {
                throw new Error(`Cannot parse string "${x}"`);
            }
            const wholePart = m[1] === '-' ? '-0' : m[1];
            const beforeCycle = m[2] ?? '';
            const cycle = m[3];
            const exponent = m[4];
            const numerator = BigInt(wholePart + beforeCycle + cycle) - BigInt(wholePart + beforeCycle);
            const denominator = BigInt('9'.repeat(cycle.length) + '0'.repeat(beforeCycle.length));
            const fraction = new Fraction(numerator, denominator);
            if (exponent !== undefined) {
                const isNegativeExp = exponent.startsWith('-');
                const exp = _10N ** BigInt(isNegativeExp ? exponent.slice(1) : exponent);
                if (isNegativeExp) {
                    return fraction.div(exp).normalize();
                }
                return fraction.mul(exp).normalize();
            }
            return fraction.simplify();
        }
        parseParameter(x) {
            if (x instanceof Fraction) {
                return x;
            }
            if (x instanceof FixedNumber) {
                return x.convertToFraction();
            }
            if (typeof x === 'number') {
                if (!Number.isSafeInteger(x)) {
                    throw new Error('Floating point values as numbers are unsafe. Please provide them as a string.');
                }
                return new Fraction(BigInt(x), _1N);
            }
            if (typeof x === 'bigint') {
                return new Fraction(x, _1N);
            }
            if (typeof x === 'string') {
                const parts = x.split('/');
                if (parts.length > 2)
                    throw new Error(`Cannot parse string '${x}'`);
                const numerator = this.parseRepeatingDecimal(parts[0]);
                const denominator = parts[1] ? this.parseRepeatingDecimal(parts[1]) : new Fraction(_1N, _1N);
                const res = numerator.div(denominator);
                const fraction = res.convertToFraction();
                return fraction;
            }
            throw new Error('Unsupported parameter!');
        }
        add(x) {
            const { numerator, denominator } = this.parseParameter(x);
            if (this.denominator === denominator) {
                return new Fraction(this.numerator + numerator, this.denominator);
            }
            // if (false) {
            //   const commonDenominator = this.lcm(this.denominator, denominator);
            //   const lMultiplier = commonDenominator / this.denominator;
            //   const rMultiplier = commonDenominator / denominator;
            //   return new Fraction(this.numerator * lMultiplier + numerator * rMultiplier, commonDenominator);
            // }
            return new Fraction(this.numerator * denominator + numerator * this.denominator, denominator * this.denominator);
        }
        sub(x) {
            const { numerator, denominator } = this.parseParameter(x);
            return this.add(new Fraction(-numerator, denominator));
        }
        mul(x) {
            const { numerator, denominator } = this.parseParameter(x);
            const res = new Fraction(this.numerator * numerator, this.denominator * denominator);
            return res;
        }
        div(x) {
            const { numerator, denominator } = this.parseParameter(x);
            return this.mul(new Fraction(denominator, numerator));
        }
        divToInt(x) {
            const num = this.div(x);
            return num.trunc();
        }
        mod(r, type = exports.ModType.TRUNCATED) {
            // n1 / d1 = n2 / d2 * q + r
            // d2 * n1 = n2 * d1 * q + d1 * d2 * r
            // (d2 * n1 % n2 * d1) / (d1 * d2)
            const rFrac = this.parseParameter(r);
            const a = (rFrac.denominator * this.numerator) % (rFrac.numerator * this.denominator);
            const b = this.denominator * rFrac.denominator;
            const res = new Fraction(a, b);
            if (type === exports.ModType.TRUNCATED) {
                return res;
            }
            if (type === exports.ModType.FLOORED) {
                return Number(this.sign() === -1) ^ Number(rFrac.sign() === -1) ? res.add(rFrac) : res;
            }
            if (type === exports.ModType.EUCLIDEAN) {
                return res.sign() === -1 ? res.add(rFrac.sign() === -1 ? rFrac.neg() : rFrac) : res;
            }
            throw new Error('Invalid ModType');
        }
        pow(x) {
            const param = this.parseParameter(x);
            if (!param.isInteger()) {
                throw new Error('Unsupported parameter');
            }
            const exp = param.numerator / param.denominator;
            const absExp = exp < _0N ? -exp : exp;
            const res = new Fraction(this.numerator ** absExp, this.denominator ** absExp);
            return exp < _0N ? res.inv() : res;
        }
        powm(_exp, _mod, modType) {
            const exp = this.parseParameter(_exp);
            if (!exp.isInteger()) {
                throw new Error('Unsupported parameter');
            }
            let expInt = exp.toNumber();
            const mod = this.parseParameter(_mod);
            let base = this;
            let res = new Fraction(_1N, _1N);
            while (expInt !== 0) {
                if (expInt % 2 !== 0) {
                    res = res.mul(base).mod(mod, modType);
                }
                base = base.pow(_2N).mod(mod, modType);
                expInt = Math.floor(expInt / 2);
            }
            return res;
        }
        inv() {
            const res = new Fraction(this.denominator, this.numerator);
            return res;
        }
        floor(decimals) {
            if (this.denominator === _1N)
                return new FixedNumber(this.numerator);
            return this.round(decimals, exports.RoundingMode.TO_NEGATIVE);
        }
        ceil(decimals) {
            if (this.denominator === _1N)
                return new FixedNumber(this.numerator);
            return this.round(decimals, exports.RoundingMode.TO_POSITIVE);
        }
        trunc(decimals) {
            if (this.denominator === _1N)
                return new FixedNumber(this.numerator);
            return this.round(decimals, exports.RoundingMode.TO_ZERO);
        }
        round(decimals, roundingMode) {
            decimals = decimals === undefined ? 0 : decimals;
            if (!Number.isSafeInteger(decimals) || decimals < 0) {
                throw new Error('Invalid value for decimals');
            }
            const fixedPart = this.toFixedNumber(decimals + 1);
            // tie case must be adjusted
            const remainder = this.sub(fixedPart);
            if (remainder.isZero()) {
                // nothing is lost
                return fixedPart.round(decimals, roundingMode);
            }
            // 0.105 might got cutted to 0.1, which might round incorrectly
            // solution: add one digit to the end
            const correctedFixedNum = new FixedNumber(`${fixedPart.toFixed(decimals + 1)}1`);
            const res = correctedFixedNum.round(decimals, roundingMode);
            return res;
        }
        roundToDigits(digits, roundingMode) {
            if (!Number.isSafeInteger(digits) || digits < 1) {
                throw new Error('Invalid value for digits');
            }
            if (this.isZero())
                return new FixedNumber(_0N);
            let x = this.abs();
            // move the number to the [0.1, 1) interval
            let divisions = 0;
            while (x.gte(_1N)) {
                x = x.div(_10N);
                divisions++;
            }
            const zeroPointOne = new Fraction(_1N, _10N);
            while (x.lt(zeroPointOne)) {
                x = x.mul(_10N);
                divisions--;
            }
            let roundedNumber = x.round(digits, roundingMode);
            roundedNumber = roundedNumber._incExponent(divisions);
            return this.sign() === -1 ? roundedNumber.neg() : roundedNumber;
        }
        gcd(numerator, denominator) {
            let a = numerator < _0N ? -numerator : numerator;
            let b = denominator < _0N ? -denominator : denominator;
            if (b > a) {
                const temp = a;
                a = b;
                b = temp;
            }
            while (true) {
                if (b === _0N)
                    return a;
                a %= b;
                if (a === _0N)
                    return b;
                b %= a;
            }
        }
        // private lcm(a: bigint, b: bigint): bigint {
        //   return (a * b) / this.gcd(a, b);
        // }
        simplify() {
            let { numerator, denominator } = this;
            const gcd = this.gcd(numerator, denominator);
            if (gcd > _1N) {
                numerator /= gcd;
                denominator /= gcd;
            }
            if (denominator < _0N) {
                numerator = -numerator;
                denominator = -denominator;
            }
            return new Fraction(numerator, denominator);
        }
        normalize() {
            const { numerator, denominator } = this.simplify();
            if (denominator === _1N) {
                return new FixedNumber(numerator, 0);
            }
            const frac = new Fraction(numerator, denominator);
            // check if conversion to FixedNumber is possible
            const { cycleLen, cycleStart } = frac.getDecimalFormat(0);
            if (cycleLen !== 0) {
                return frac;
            }
            return frac.round(cycleStart, exports.RoundingMode.TO_ZERO);
        }
        getFractionParts(normalize = true) {
            const num = normalize ? this.simplify() : this;
            return {
                numerator: new FixedNumber(num.numerator),
                denominator: new FixedNumber(num.denominator),
            };
        }
        sign() {
            const numeratorSign = this.numerator < _0N ? -1 : 1;
            const denominatorSign = this.denominator < _0N ? -1 : 1;
            return (numeratorSign * denominatorSign);
        }
        abs() {
            const res = new Fraction(this.numerator < _0N ? -this.numerator : this.numerator, this.denominator < _0N ? -this.denominator : this.denominator);
            return res;
        }
        neg() {
            return this.mul(-_1N);
        }
        intPart() {
            return this.trunc();
        }
        fracPart() {
            return this.sub(this.trunc());
        }
        cmp(x) {
            const rVal = this.parseParameter(x);
            const hasCommonDenominator = this.denominator === rVal.denominator;
            const a = hasCommonDenominator ? this.numerator : this.numerator * rVal.denominator;
            const b = hasCommonDenominator ? rVal.numerator : rVal.numerator * this.denominator;
            if (a === b)
                return 0;
            return a > b ? 1 : -1;
        }
        eq(x) {
            return this.cmp(x) === 0;
        }
        lt(x) {
            return this.cmp(x) === -1;
        }
        lte(x) {
            return this.cmp(x) <= 0;
        }
        gt(x) {
            return this.cmp(x) === 1;
        }
        gte(x) {
            return this.cmp(x) >= 0;
        }
        clamp(min, max) {
            const minNum = ExactNumber(min);
            const maxNum = ExactNumber(max);
            if (minNum.gt(maxNum))
                throw new Error('Min parameter has to be smaller than max');
            if (this.lt(minNum))
                return minNum;
            if (this.gt(maxNum))
                return maxNum;
            return this;
        }
        isZero() {
            return this.numerator === _0N;
        }
        isOne() {
            return this.numerator === this.denominator;
        }
        isInteger() {
            return this.numerator % this.denominator === _0N;
        }
        serialize() {
            return [this.numerator, this.denominator];
        }
        toNumber() {
            return Number(this.toPrecision(20));
        }
        convertToFraction() {
            return this;
        }
        getNumberForBitwiseOp() {
            if (!this.isInteger() || this.sign() === -1) {
                throw new Error('Only positive integers are supported');
            }
            return this.intPart();
        }
        bitwiseAnd(x) {
            return this.getNumberForBitwiseOp().bitwiseAnd(x);
        }
        bitwiseOr(x) {
            return this.getNumberForBitwiseOp().bitwiseOr(x);
        }
        bitwiseXor(x) {
            return this.getNumberForBitwiseOp().bitwiseXor(x);
        }
        shiftLeft(bitCount) {
            return this.getNumberForBitwiseOp().shiftLeft(bitCount);
        }
        shiftRight(bitCount) {
            return this.getNumberForBitwiseOp().shiftRight(bitCount);
        }
        getDecimalFormat(maxDigits) {
            maxDigits = maxDigits === undefined ? Number.MAX_SAFE_INTEGER : maxDigits;
            let d = this.denominator < _0N ? -this.denominator : this.denominator;
            let twoExp = 0;
            while (d % _2N === _0N) {
                d /= _2N;
                twoExp++;
            }
            let fiveExp = 0;
            while (d % _5N === _0N) {
                d /= _5N;
                fiveExp++;
            }
            const cycleStart = Math.max(twoExp, fiveExp);
            if (d === _1N) {
                return { cycleLen: 0, cycleStart };
            }
            const end = Math.max(1, maxDigits - cycleStart);
            let rem = _10N % d;
            let cycleLen = 1;
            // 10^l â‰¡ 1 (mod d)
            while (rem !== _1N) {
                if (cycleLen === end) {
                    // abort calculation
                    return { cycleLen: null, cycleStart };
                }
                rem = (rem * _10N) % d;
                cycleLen++;
            }
            return { cycleLen, cycleStart };
        }
        toFixed(decimals, roundingMode = exports.RoundingMode.TO_ZERO, trimZeros = false) {
            if (!Number.isSafeInteger(decimals) || decimals < 0)
                throw new Error('Invalid parameter');
            return this.round(decimals, roundingMode).toFixed(decimals, exports.RoundingMode.TO_ZERO, trimZeros);
        }
        toRepeatingParts(maxDigits) {
            if (this.isZero()) {
                return ['0', '', ''];
            }
            const { cycleLen, cycleStart } = this.simplify().getDecimalFormat(maxDigits);
            // if aborted calculation or terminating decimal
            if (cycleLen === null || cycleLen === 0) {
                const outputDigits = maxDigits ?? cycleStart;
                const str = this.toFixed(outputDigits);
                const parts = trimTrailingZerosFromFixed(str).split('.');
                return [parts[0], parts[1] ?? '', ''];
            }
            const digits = cycleStart + cycleLen;
            const str = this.toFixed(digits);
            const parts = str.split('.');
            return [parts[0], parts[1].slice(0, cycleStart), parts[1].slice(cycleStart)];
        }
        toRepeatingDigits(maxDigits) {
            const parts = this.toRepeatingParts(maxDigits);
            let res = parts[0];
            if (parts[1] || parts[2]) {
                res += `.${parts[1]}`;
            }
            if (parts[2]) {
                res += `(${parts[2]})`;
            }
            return res;
        }
        toExponential(digits, roundingMode = exports.RoundingMode.TO_ZERO, trimZeros = false) {
            if (!Number.isSafeInteger(digits) || digits < 0)
                throw new Error('Invalid parameters');
            const fixedNum = this.toFixedNumber(digits);
            return fixedNum.toExponential(digits, roundingMode, trimZeros);
        }
        toFraction() {
            const { numerator, denominator } = this.getFractionParts(true);
            return `${numerator.toString()}/${denominator.toString()}`;
        }
        toFixedNumber(digits) {
            const numerator = this.numerator * _10N ** BigInt(digits);
            const fixedNum = new FixedNumber(numerator / this.denominator, digits);
            return fixedNum;
        }
        toBase(radix, maxDigits) {
            if (!Number.isSafeInteger(radix) || radix < 2 || radix > 16)
                throw new Error('Invalid radix');
            if (maxDigits !== undefined && (!Number.isSafeInteger(maxDigits) || maxDigits < 0)) {
                throw new Error('Invalid parameter');
            }
            if (radix === 10) {
                return maxDigits === undefined
                    ? this.toRepeatingDigits(maxDigits)
                    : trimTrailingZerosFromFixed(this.toFixed(maxDigits));
            }
            const num = this.normalize();
            const loopEnd = maxDigits === undefined ? Number.MAX_SAFE_INTEGER : maxDigits + 1;
            let intPart = num.intPart();
            let fracPart = num.sub(intPart);
            const isNegative = num.sign() === -1;
            if (isNegative) {
                intPart = intPart.neg();
                fracPart = fracPart.neg();
            }
            const match = new Map();
            let digits = [];
            while (!fracPart.isZero()) {
                if (digits.length === loopEnd)
                    break;
                const mul = fracPart.mul(radix);
                const mulStr = mul.normalize().toFraction();
                const cycleStart = match.get(mulStr);
                if (cycleStart !== undefined) {
                    digits = [...digits.slice(0, cycleStart - 1), '(', ...digits.slice(cycleStart - 1), ')'];
                    break;
                }
                const q = Math.abs(mul.intPart().toNumber());
                digits.push(q.toString(radix));
                fracPart = mul.fracPart();
                match.set(mulStr, digits.length);
            }
            if (digits.length === loopEnd) {
                digits.pop();
            }
            const digitsStr = digits.join('');
            const res = `${isNegative ? '-' : ''}${intPart.toString(radix)}${digits.length ? '.' : ''}${digitsStr}`;
            return res;
        }
        toString(radix, maxDigits) {
            if (radix === undefined || radix === 10) {
                return this.toRepeatingDigits(maxDigits);
            }
            return this.toBase(radix, maxDigits);
        }
        toPrecision(digits, roundingMode = exports.RoundingMode.TO_ZERO, trimZeros = false) {
            if (!Number.isSafeInteger(digits) || digits < 1)
                throw new Error('Invalid parameter');
            return this.roundToDigits(digits, roundingMode).toPrecision(digits, exports.RoundingMode.TO_ZERO, trimZeros);
        }
        valueOf() {
            throw new Error('Unsafe conversion to Number type! Use toNumber() instead.');
        }
    }

    function parseParameter(x) {
        if (x instanceof FixedNumber || x instanceof Fraction) {
            return x;
        }
        if (typeof x === 'bigint') {
            return new FixedNumber(x);
        }
        if (typeof x === 'number') {
            if (!Number.isSafeInteger(x)) {
                throw new Error('Floating point values as numbers are unsafe. Please provide them as a string.');
            }
            return new FixedNumber(x);
        }
        if (typeof x === 'string') {
            if (x.includes('/') || x.includes('(')) {
                return new Fraction(x, _1N);
            }
            return new FixedNumber(x);
        }
        throw new Error('Unsupported parameter type');
    }
    const ExactNumber = ((x, y) => {
        if (x === undefined) {
            throw new Error('First parameter cannot be undefined');
        }
        const xVal = parseParameter(x);
        if (y === undefined) {
            return xVal;
        }
        const yVal = parseParameter(y);
        return new Fraction(xVal, _1N).div(new Fraction(yVal, _1N));
    });
    ExactNumber.min = ((...params) => {
        if (params.length === 0) {
            throw new Error('Got empty array');
        }
        let minVal = ExactNumber(params[0]);
        for (let i = 1; i < params.length; i++) {
            const x = ExactNumber(params[i]);
            if (x.lt(minVal)) {
                minVal = x;
            }
        }
        return minVal;
    });
    ExactNumber.max = ((...params) => {
        if (params.length === 0) {
            throw new Error('Got empty array');
        }
        let maxVal = ExactNumber(params[0]);
        for (let i = 1; i < params.length; i++) {
            const x = ExactNumber(params[i]);
            if (x.gt(maxVal)) {
                maxVal = x;
            }
        }
        return maxVal;
    });
    const parseDigitsInBase = (str, radix) => {
        let res = _0N;
        for (let i = 0; i < str.length; i++) {
            const c = str.charAt(i);
            const digit = parseInt(c, radix);
            if (Number.isNaN(digit)) {
                throw new Error(`Invalid digit "${c}"`);
            }
            res *= BigInt(radix);
            res += BigInt(digit);
        }
        return res;
    };
    ExactNumber.fromBase = ((num, radix) => {
        if (typeof num !== 'string') {
            throw new Error('First parameter must be string');
        }
        if (!Number.isSafeInteger(radix) || radix < 2 || radix > 16) {
            throw new Error('Invalid radix');
        }
        if (radix === 10) {
            return ExactNumber(num);
        }
        num = num.trim();
        if (num.length === 0)
            throw new Error('Empty string is not allowed');
        const isNegative = num.startsWith('-');
        if (isNegative) {
            num = num.slice(1);
        }
        const m = num.match(/^([0-9a-f]*)(?:\.([0-9a-f]*)(?:\(([0-9a-f]+)\))?)?$/i);
        if (!m) {
            throw new Error(`Cannot parse number "${num}"`);
        }
        const wholePartStr = m[1] ?? '';
        const nonRepeatingPartStr = m[2] ?? '';
        const repeatingPartStr = m[3] ?? '';
        if (repeatingPartStr.length > 0) {
            const numerator = parseDigitsInBase(`${wholePartStr}${nonRepeatingPartStr}${repeatingPartStr}`, radix) -
                parseDigitsInBase(`${wholePartStr}${nonRepeatingPartStr}`, radix);
            const denominator = parseDigitsInBase((radix - 1).toString(radix).repeat(repeatingPartStr.length) + '0'.repeat(nonRepeatingPartStr.length), radix);
            const res = new Fraction(numerator, denominator).normalize();
            return isNegative ? res.neg() : res;
        }
        const whole = parseDigitsInBase(wholePartStr, radix);
        const nonRepeating = parseDigitsInBase(nonRepeatingPartStr, radix);
        const fracPath = new Fraction(nonRepeating, BigInt(radix) ** BigInt(nonRepeatingPartStr.length));
        const res = new Fraction(whole, _1N).add(fracPath).normalize();
        return isNegative ? res.neg() : res;
    });
    /** Used to iterate over exact rational numbers.
     * E.g. Iterating from -2 to 3 with 0.5 increments:
     * for(const x of ExactNumber.range(-2, 3, '0.5')) {} */
    // eslint-disable-next-line func-names
    ExactNumber.range = function* (_start, _end, _increment) {
        const end = ExactNumber(_end);
        const increment = ExactNumber(_increment ?? 1);
        let i = ExactNumber(_start);
        while (i.lt(end)) {
            yield i;
            i = i.add(increment);
        }
    };
    ExactNumber.gcd = ((a, b) => {
        const aNum = ExactNumber(a).abs();
        const bNum = ExactNumber(b).abs();
        let maxNum = bNum.gt(aNum) ? bNum : aNum;
        let minNum = maxNum.eq(aNum) ? bNum : aNum;
        while (true) {
            if (minNum.isZero())
                return maxNum;
            maxNum = maxNum.mod(minNum);
            if (maxNum.isZero())
                return minNum;
            minNum = minNum.mod(maxNum);
        }
    });
    ExactNumber.lcm = ((a, b) => {
        const aNum = ExactNumber(a).abs();
        const bNum = ExactNumber(b).abs();
        const product = aNum.mul(bNum);
        if (product.isZero())
            throw new Error('LCM of zero is undefined');
        const gcd = ExactNumber.gcd(aNum, bNum);
        return product.div(gcd);
    });
    // ExactNumber.modpow

    const approximateNthRoot = (n, x) => {
        let xNum = x.toNumber();
        if (Number.isFinite(xNum)) {
            // JS doesn't work well with powers of negative numbers
            const isNegative = xNum < 0;
            if (isNegative) {
                xNum = -xNum;
            }
            let guess = xNum ** (1 / n);
            if (isNegative) {
                guess = -guess;
            }
            return guess.toString();
        }
        // approximate number of digits in the output number
        const xDigits = x.abs().toFixed(0).length;
        const outputDigits = Math.ceil(xDigits / n);
        const sign = x.sign() === 1 ? '' : '-';
        return `${sign}5e${outputDigits}`;
    };
    // Newton's method
    const nthrootWithNewton = (n, x, decimals) => {
        const initialGuess = approximateNthRoot(n, x);
        let xk = new FixedNumber(initialGuess !== '0' ? initialGuess : '1');
        const c0 = new Fraction(n - 1, n);
        const c1 = new Fraction(x, n);
        const c2 = BigInt(n - 1);
        let last = xk.trunc(decimals + 5);
        while (true) {
            xk = c0.mul(xk).add(c1.mul(xk.pow(c2).inv()));
            xk = xk.trunc(decimals + 5);
            if (xk.isZero() || last.eq(xk)) {
                break;
            }
            last = xk;
        }
        return xk.trunc(decimals);
    };
    const nthroot = (n, x, decimals) => {
        if (!Number.isSafeInteger(n))
            throw new Error('Integer is expected for N');
        if (n < 0)
            throw new Error('Negative N is not supported');
        if (n === 0)
            throw new Error('N cannot be zero');
        const xNum = limitDecimals(ExactNumber(x), decimals);
        if (n === 1) {
            return xNum.trunc(decimals);
        }
        if (n % 2 === 0 && xNum.sign() === -1)
            throw new Error('Complex numbers are not supported');
        if (xNum.isZero())
            return new FixedNumber(_0N).trunc(decimals);
        if (xNum.isOne())
            return new FixedNumber(_1N).trunc(decimals);
        const res = nthrootWithNewton(n, xNum, decimals);
        return res;
    };
    const sqrt = (x, decimals) => nthroot(2, x, decimals);
    const cbrt = (x, decimals) => nthroot(3, x, decimals);

    class ConstantCache {
        constructor(fn, max) {
            this.cachedDecimals = 0;
            this.fn = fn;
            this.max = max;
        }
        get(decimals) {
            if (decimals <= this.cachedDecimals) {
                return this.cache.trunc(decimals);
            }
            const calculated = new FixedNumber(this.fn(decimals));
            const decimalsCached = Math.min(this.max, decimals);
            if (this.cachedDecimals !== decimalsCached) {
                this.cache = calculated.trunc(decimalsCached);
                this.cachedDecimals = decimalsCached;
            }
            return calculated;
        }
    }

    // ln(x) = ln((1 + y)/(1 - y)) = 2(y + y^3/3 + y^5/5 + y^7/7 + ...)
    // y = (x - 1)/(x + 1) (|y| < 1)
    function* logGenerator(y, decimals) {
        const y2 = y.pow(_2N).normalize();
        let numerator = y;
        let denominator = _1N;
        let sum = ExactNumber(y);
        while (true) {
            numerator = numerator.mul(y2);
            denominator += _2N;
            const term = numerator.div(denominator).trunc(decimals + 10);
            sum = sum.add(term);
            yield { term, sum };
        }
    }
    const log = (x, decimals) => {
        let input = limitDecimals(ExactNumber(x), decimals);
        if (input.isOne()) {
            return new FixedNumber(0).trunc(decimals);
        }
        if (input.lte(0)) {
            throw new Error('Invalid parameter');
        }
        // fastest convergence at 1
        // ln(x) = 2 * ln(sqrt(x))
        let reductions = 0;
        const reductionLimit = ExactNumber('0.1');
        while (input.sub(_1N).abs().gt(reductionLimit)) {
            input = new FixedNumber(sqrt(input, decimals + 10));
            reductions++;
        }
        // ln(x) = ln((1 + y)/(1 - y)) = 2(y + y^3/3 + y^5/5 + y^7/7 + ...)
        // y = (x - 1)/(x + 1) (|y| < 1)
        const y = input.sub(_1N).div(input.add(_1N));
        const gen = logGenerator(y, decimals);
        for (const { term, sum } of gen) {
            if (term.isZero()) {
                // undo reductions
                const res = sum.mul(_2N ** BigInt(reductions + 1));
                return res.trunc(decimals);
            }
        }
        return ExactNumber(_0N);
    };
    const logn = (n, x, decimals) => {
        if (!Number.isSafeInteger(n) || n < 2)
            throw new Error('Invalid parameter for N');
        const numerator = log(x, decimals + 10);
        const denominator = log(n, decimals + 10);
        const res = new FixedNumber(numerator).div(denominator);
        return res.trunc(decimals);
    };
    const LOG_2 = new ConstantCache(decimals => log(_2N, decimals), 200);
    const log2 = (x, decimals) => {
        const res = new FixedNumber(log(x, decimals + 10)).div(LOG_2.get(decimals + 10));
        return res.trunc(decimals);
    };
    const LOG_10 = new ConstantCache(decimals => log(_10N, decimals), 200);
    const log10 = (x, decimals) => {
        const res = new FixedNumber(log(x, decimals + 10)).div(LOG_10.get(decimals + 10));
        return res.trunc(decimals);
    };

    // e^x = 1 + x + x^2/2! + x^3/3! + ...
    function* expGenerator(x, decimals) {
        let sum = x.add(1);
        let denominator = BigInt(6);
        let i = _4N;
        const xPow2 = x.pow(_2N);
        let xPow = xPow2;
        while (true) {
            // x^2/2! + x^3/3!
            // = (x^2*(3+x))/3!
            const term = xPow.mul(x.add(i - _1N)).div(denominator);
            denominator *= i * (i + _1N);
            i += _2N;
            xPow = xPow.mul(xPow2);
            sum = sum.add(term).trunc(decimals + 5);
            yield { term, sum };
        }
    }
    // TODO: try computing via exp(x) = sinh(x) + sqrt(1 + sinh(x) ** 2)
    const exp = (x, decimals) => {
        const xVal = limitDecimals(ExactNumber(x), decimals);
        const maxError = ExactNumber(`1e-${decimals + 5}`);
        const gen = expGenerator(xVal, decimals);
        for (const { term, sum } of gen) {
            if (term.abs().lt(maxError)) {
                return sum.trunc(decimals);
            }
        }
        return ExactNumber(_0N);
    };
    const pow = (_base, _exponent, decimals) => {
        const base = limitDecimals(ExactNumber(_base), decimals);
        const exponent = limitDecimals(ExactNumber(_exponent), decimals);
        if (exponent.isInteger() && Number.isSafeInteger(exponent.toNumber())) {
            return base.pow(exponent).trunc(decimals);
        }
        // x^y = exp(y*ln(x))
        if (base.sign() === -1 && !exponent.isInteger()) {
            throw new Error('Complex numbers are not supported');
        }
        const logbase = log(base, decimals + 5);
        const param = exponent.mul(logbase);
        return exp(param, decimals + 5).trunc(decimals);
    };

    // TODO: https://en.wikipedia.org/wiki/Niven%27s_theorem
    // On Lambert's Proof of the Irrationality of Ï€: https://www.jstor.org/stable/2974737
    // Faster solution here -> https://arxiv.org/pdf/1706.08835.pdf
    const PIcalc = (decimals) => {
        if (decimals === 0)
            return ExactNumber(_3N);
        // PI = 3 + 3(1/2)(1/3)(1/4) + 3((1/2)(3/4))(1/5)(1/4^2) + 3((1/2)(3/4)(5/6))(1/7)(1/4^3) + ...
        let i = _1N;
        let x = _3N * _10N ** BigInt(decimals + 20);
        let res = x;
        while (x !== _0N) {
            x = (x * i) / ((i + _1N) * _4N);
            i += _2N;
            res += x / i;
        }
        return ExactNumber(`3.${res.toString().slice(1, decimals + 1)}`);
    };
    const PI_CACHE = new ConstantCache(PIcalc, 1000);
    const PI = (decimals) => {
        if (decimals === 0)
            return ExactNumber(_3N);
        return PI_CACHE.get(decimals).trunc(decimals);
    };
    const getMultiplierOf = (x, y, decimals) => {
        const precision = Math.max(3, decimals);
        const input = x.trunc(precision);
        const closestQuotient = input.div(y).round();
        const ref = y.mul(closestQuotient).trunc(precision);
        if (ref.eq(input)) {
            return closestQuotient;
        }
        return null;
    };
    const evaluateSpecialAngle = (angleMultiplier) => {
        let multiplier = angleMultiplier.mod(_24N).toNumber();
        if (multiplier < 0) {
            multiplier += 24;
        }
        const quadrant = Math.floor(multiplier / 6) + 1;
        let specialCaseDeg = multiplier * 15;
        if (quadrant === 4) {
            specialCaseDeg = 360 - specialCaseDeg;
        }
        else if (quadrant === 3) {
            specialCaseDeg -= 180;
        }
        else if (quadrant === 2) {
            specialCaseDeg = 180 - specialCaseDeg;
        }
        return {
            specialCaseDeg,
            quadrant,
            subHalfPiAngle: null,
        };
    };
    const evaluateAngle = (x, decimals) => {
        let angle = x.round(decimals + 5, exports.RoundingMode.NEAREST_AWAY_FROM_ZERO);
        const pi = PI(decimals + 5);
        const angleMultiplier = getMultiplierOf(angle, pi.div(12), decimals);
        if (angleMultiplier !== null) {
            return evaluateSpecialAngle(angleMultiplier);
        }
        const twoPi = pi.mul(_2N);
        angle = angle.mod(twoPi);
        if (angle.sign() === -1) {
            angle = angle.add(twoPi);
        }
        const quadrant = angle.mul(_2N).div(pi).floor().toNumber() + 1;
        let subHalfPiAngle = angle;
        if (quadrant === 4) {
            subHalfPiAngle = twoPi.sub(subHalfPiAngle);
        }
        else if (quadrant === 3) {
            subHalfPiAngle = subHalfPiAngle.sub(pi);
        }
        else if (quadrant === 2) {
            subHalfPiAngle = pi.sub(subHalfPiAngle);
        }
        return {
            specialCaseDeg: null,
            quadrant,
            subHalfPiAngle,
        };
    };
    // cos x = 1 - x^2/2! + x^4/4! - ...
    function* cosGenerator(x, decimals) {
        const x2 = x.round(decimals + 10, exports.RoundingMode.NEAREST_AWAY_FROM_ZERO).pow(_2N);
        let xPow = x2;
        let termDenominator = _2N;
        let sum = ExactNumber(_1N).sub(xPow.div(termDenominator).trunc(decimals + 10));
        let i = _3N;
        while (true) {
            // term = x^4/4! - x^6/6!
            // = (5*6*x^4 - x^6)/6!
            termDenominator *= i * (i + _1N);
            i += _2N;
            const multiplier = i * (i + _1N);
            i += _2N;
            xPow = xPow.mul(x2);
            termDenominator *= multiplier;
            let termNumerator = xPow.mul(multiplier);
            xPow = xPow.mul(x2);
            termNumerator = termNumerator.sub(xPow);
            const term = termNumerator.div(termDenominator).trunc(decimals + 10);
            sum = sum.add(term);
            // max lagrange error = x^(k+1)/(k+1)!
            yield { term, sum };
        }
    }
    const resultHandler = (value, shouldNegate, decimals) => {
        let convertedValue = ExactNumber(value);
        if (shouldNegate) {
            convertedValue = convertedValue.neg();
        }
        return convertedValue.trunc(decimals);
    };
    const getCosSpecialValue = (angleDeg, shouldNegate, decimals) => {
        let res;
        if (angleDeg === 0) {
            res = _1N;
        }
        else if (angleDeg === 30) {
            res = ExactNumber(sqrt(_3N, decimals + 5)).div(_2N);
        }
        else if (angleDeg === 45) {
            res = ExactNumber(sqrt(_2N, decimals + 5)).div(_2N);
        }
        else if (angleDeg === 60) {
            res = '0.5';
        }
        else if (angleDeg === 90) {
            res = _0N;
        }
        else {
            throw new Error();
        }
        return resultHandler(res, shouldNegate, decimals);
    };
    const cos = (_angle, decimals) => {
        const EXTRA_DECIMALS = decimals + 10;
        const angle = limitDecimals(ExactNumber(_angle), decimals + 5);
        const { specialCaseDeg, subHalfPiAngle: x, quadrant } = evaluateAngle(angle, decimals);
        const shouldNegate = quadrant === 2 || quadrant === 3;
        if (specialCaseDeg !== null) {
            return getCosSpecialValue(specialCaseDeg, shouldNegate, decimals);
        }
        const maxError = ExactNumber(`1e-${EXTRA_DECIMALS}`);
        const gen = cosGenerator(x, decimals);
        for (const { term, sum } of gen) {
            if (term.lt(maxError)) {
                return resultHandler(sum, shouldNegate, decimals);
            }
        }
        return ExactNumber(0);
    };
    const sin = (_angle, decimals) => {
        const angle = limitDecimals(ExactNumber(_angle), decimals + 5);
        const { specialCaseDeg, quadrant } = evaluateAngle(angle, decimals);
        const shouldNegate = quadrant === 3 || quadrant === 4;
        if (specialCaseDeg !== null) {
            return getCosSpecialValue(90 - specialCaseDeg, shouldNegate, decimals);
        }
        const pi = new FixedNumber(PI(decimals + 5));
        return cos(pi.div(_2N).sub(angle), decimals + 5).trunc(decimals);
    };
    const tan = (angle, decimals) => {
        const angleNum = limitDecimals(ExactNumber(angle), decimals + 5);
        const { specialCaseDeg, quadrant, subHalfPiAngle: x } = evaluateAngle(angleNum, decimals);
        const shouldNegate = quadrant === 2 || quadrant === 4;
        if (specialCaseDeg !== null) {
            if (specialCaseDeg === 0)
                return resultHandler('0', shouldNegate, decimals);
            if (specialCaseDeg === 30) {
                return resultHandler(ExactNumber(_1N).div(sqrt(_3N, decimals + 5)), shouldNegate, decimals);
            }
            if (specialCaseDeg === 45) {
                return resultHandler('1', shouldNegate, decimals);
            }
            if (specialCaseDeg === 60)
                return resultHandler(sqrt(_3N, decimals + 5), shouldNegate, decimals);
            if (specialCaseDeg === 90) {
                throw new Error('Out of range');
            }
            throw new Error();
        }
        // tan x = sqrt((1 - cos(2x)) / 1 + cos(2x))
        const cos2x = ExactNumber(cos(x.mul(_2N), decimals + 5));
        const res = ExactNumber(_1N)
            .sub(cos2x)
            .div(ExactNumber(_1N).add(cos2x))
            .round(decimals + 5);
        const root = sqrt(res, decimals + 5).trunc(decimals);
        return shouldNegate ? root.neg() : root;
    };

    // atan x = x - x^3/3 + x^5/5 - x^7/7 + ...
    function* atanGenerator(x, decimals) {
        const x2 = x.pow(_2N).normalize();
        const x4 = x2.pow(_2N).normalize();
        let denominator = _3N;
        let sum = x.sub(x.mul(x2).div(denominator));
        let xPow = x.mul(x4);
        while (true) {
            // x^5/d - x^7/(d + 2)
            // = x^5 * (-ax^2 + (a + 2)) / (a * (a + 2))
            denominator += _2N;
            const denominator2 = denominator + _2N;
            const numerator = xPow.mul(x2.mul(-denominator).add(denominator2));
            const term = numerator.div(denominator * denominator2);
            denominator = denominator2;
            xPow = xPow.mul(x4);
            sum = sum.add(term).trunc(decimals + 10);
            yield { term, sum };
        }
    }
    const atan = (value, decimals) => {
        let x = limitDecimals(ExactNumber(value), decimals);
        if (x.isZero())
            return ExactNumber(0);
        if (x.abs().isOne()) {
            return ExactNumber(PI(decimals))
                .div(4 * x.sign())
                .trunc(decimals);
        }
        // Ensure |x| < 0.42
        // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))
        let reductionSteps = 0;
        const reductionLimit = ExactNumber('0.42');
        while (x.abs().gt(reductionLimit)) {
            const root = ExactNumber(sqrt(x.pow(_2N).add(_1N), decimals + 10));
            x = x.div(root.add(_1N));
            reductionSteps++;
        }
        const maxError = ExactNumber(`1e-${decimals + 10}`);
        const gen = atanGenerator(x, decimals);
        for (const { term, sum } of gen) {
            if (term.abs().lt(maxError)) {
                // undo argument reduction
                const res = sum.mul(_2N ** BigInt(reductionSteps));
                return res.trunc(decimals);
            }
        }
        return ExactNumber(0);
    };
    const asin = (value, decimals) => {
        const x = limitDecimals(ExactNumber(value), decimals);
        if (x.isZero())
            return ExactNumber(_0N);
        if (x.abs().isOne()) {
            return ExactNumber(PI(decimals)).mul(x.sign()).div(_2N).trunc(decimals);
        }
        if (x.abs().eq('1/2')) {
            return ExactNumber(PI(decimals)).mul(x.sign()).div(6).trunc(decimals);
        }
        if (x.gt(_1N) || x.lt(-_1N)) {
            throw new Error('Out of range');
        }
        // asin(x) = 2*atan(x / (1 + sqrt(1 - x^2)))
        const root = ExactNumber(sqrt(x.pow(_2N).neg().add(_1N), decimals + 10));
        const atangent = ExactNumber(atan(x.div(root.add(_1N)), decimals + 10));
        return atangent.mul(_2N).trunc(decimals);
    };
    const acos = (value, decimals) => {
        const x = limitDecimals(ExactNumber(value), decimals);
        if (x.isZero())
            return ExactNumber(PI(decimals)).div(_2N).trunc(decimals);
        if (x.isOne()) {
            return ExactNumber(_0N);
        }
        if (x.abs().isOne()) {
            return PI(decimals);
        }
        if (x.abs().eq('1/2')) {
            const PI_OVER_3 = ExactNumber(PI(decimals)).div(_3N);
            return x.sign() === -1 ? PI_OVER_3.mul(_2N).trunc(decimals) : PI_OVER_3.trunc(decimals);
        }
        if (x.gt(_1N) || x.lt(-_1N)) {
            throw new Error('Out of range');
        }
        // acos(x) = pi/2 - asin(x)
        return ExactNumber(PI(decimals + 10))
            .div(_2N)
            .sub(asin(x, decimals + 10))
            .trunc(decimals);
    };

    // sinh x = x + x^3/3! + x^5/5! + ...
    function* sinhGenerator(x, decimals) {
        let numerator = x;
        let denominator = _1N;
        const x2 = x.pow(_2N).normalize();
        let sum = x.trunc(decimals + 5);
        let i = _2N;
        while (true) {
            numerator = numerator.mul(x2);
            denominator *= i * (i + _1N);
            i += _2N;
            const term = numerator.div(denominator);
            sum = sum.add(term).trunc(decimals + 5);
            yield { term, sum };
        }
    }
    const sinh = (x, decimals) => {
        const input = limitDecimals(ExactNumber(x), decimals);
        const maxError = new FixedNumber(`1e-${decimals + 5}`);
        const gen = sinhGenerator(input, decimals);
        for (const { term, sum } of gen) {
            if (term.abs().lt(maxError)) {
                return sum.trunc(decimals);
            }
        }
        return ExactNumber(_0N);
    };
    // cosh x = 1 + x^2/2! + x^4/4! + ...
    function* coshGenerator(x, decimals) {
        const x2 = x.pow(_2N).normalize();
        let numerator = x2;
        let denominator = _2N;
        let sum = numerator
            .div(denominator)
            .add(_1N)
            .trunc(decimals + 5);
        let i = _3N;
        while (true) {
            numerator = numerator.mul(x2);
            denominator *= i * (i + _1N);
            i += _2N;
            const term = numerator.div(denominator);
            sum = sum.add(term).trunc(decimals + 5);
            yield { term, sum };
        }
    }
    const cosh = (x, decimals) => {
        const input = limitDecimals(ExactNumber(x), decimals);
        const maxError = new FixedNumber(`1e-${decimals + 5}`);
        const gen = coshGenerator(input, decimals);
        for (const { term, sum } of gen) {
            if (term.abs().lt(maxError)) {
                return sum.trunc(decimals);
            }
        }
        return ExactNumber(_0N);
    };
    const tanh = (angle, decimals) => {
        const angleNum = limitDecimals(ExactNumber(angle), decimals);
        if (angleNum.isZero())
            return ExactNumber(_0N);
        // tanh x = sinh x / cosh x;
        // sinh x = sqrt((cosh(x)^2) - 1);
        const coshRes = cosh(angleNum, decimals + 10).abs();
        const sinhRes = sqrt(coshRes.pow(_2N).sub(_1N), decimals + 10);
        const res = sinhRes.div(coshRes).mul(angleNum.sign());
        return res.trunc(decimals);
    };

    const asinh = (x, decimals) => {
        const input = limitDecimals(ExactNumber(x), decimals);
        if (input.isZero())
            return ExactNumber(_0N);
        // asinh(x) = ln(x + sqrt(x^2 + 1))
        const root = sqrt(input.pow(_2N).add(_1N), decimals + 5);
        const res = log(input.add(root), decimals + 5);
        return res.trunc(decimals);
    };
    const acosh = (x, decimals) => {
        const input = limitDecimals(ExactNumber(x), decimals);
        if (input.isOne())
            return ExactNumber(_0N);
        if (input.lt(_1N))
            throw new Error('Out of range');
        // acosh(x) = ln(x + sqrt(x^2 - 1))
        const root = sqrt(input.pow(_2N).sub(_1N), decimals + 5);
        const res = log(input.add(root), decimals + 5);
        return res.trunc(decimals);
    };
    const atanh = (x, decimals) => {
        const input = limitDecimals(ExactNumber(x), decimals);
        if (input.abs().gte(_1N))
            throw new Error('Out of range');
        if (input.isZero())
            return ExactNumber(_0N);
        // atanh(x) = 0.5 * ln((1 + x) / (1 - x))
        const res = log(input.add(_1N).div(input.neg().add(_1N)), decimals + 5);
        return ExactNumber(res).div(_2N).trunc(decimals);
    };

    exports.ExactNumber = ExactNumber;
    exports.PI = PI;
    exports.acos = acos;
    exports.acosh = acosh;
    exports.asin = asin;
    exports.asinh = asinh;
    exports.atan = atan;
    exports.atanh = atanh;
    exports.cbrt = cbrt;
    exports.cos = cos;
    exports.cosh = cosh;
    exports.exp = exp;
    exports.log = log;
    exports.log10 = log10;
    exports.log2 = log2;
    exports.logn = logn;
    exports.nthroot = nthroot;
    exports.pow = pow;
    exports.sin = sin;
    exports.sinh = sinh;
    exports.sqrt = sqrt;
    exports.tan = tan;
    exports.tanh = tanh;

}));
