/*!
 * exactnumber v1.0.1 (https://www.npmjs.com/package/exactnumber)
 * (c) Dani Biro
 * @license MIT
 */

!function(t,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r((t="undefined"!=typeof globalThis?globalThis:t||self).exactnumber={})}(this,(function(t){"use strict";var r,e;t.RoundingMode=void 0,(r=t.RoundingMode||(t.RoundingMode={}))[r.NEAREST_TO_POSITIVE=201008]="NEAREST_TO_POSITIVE",r[r.NEAREST_TO_NEGATIVE=201009]="NEAREST_TO_NEGATIVE",r[r.NEAREST_TO_EVEN=201010]="NEAREST_TO_EVEN",r[r.NEAREST_TO_ZERO=201011]="NEAREST_TO_ZERO",r[r.NEAREST_AWAY_FROM_ZERO=201012]="NEAREST_AWAY_FROM_ZERO",r[r.TO_POSITIVE=201001]="TO_POSITIVE",r[r.TO_NEGATIVE=201002]="TO_NEGATIVE",r[r.TO_ZERO=201003]="TO_ZERO",r[r.AWAY_FROM_ZERO=201004]="AWAY_FROM_ZERO",t.ModType=void 0,(e=t.ModType||(t.ModType={})).TRUNCATED="T",e.FLOORED="F",e.EUCLIDEAN="E";const n=t=>{const r=t.indexOf(".");if(-1===r)return t;let e=t.length;for(;e>r&&"0"===t.charAt(e-1);)e--;const n=r===e-1?r:e;return 0===n?"0":t.slice(0,n)},i=(t,r,e,i)=>{let o=t.toString();if(0===r&&0===e)return o;const s=o.startsWith("-");if(s&&(o=o.slice(1)),r>=o.length&&(o="0".repeat(r-o.length+1)+o),r>0){const t=o.slice(0,-r),s=o.slice(-r),u=e<=r?s.slice(0,e):`${s}${"0".repeat(e-r)}`;0!==u.length?(o=`${t}.${u}`,i&&(o=n(o))):o=t}else e>0&&!i&&(o=`${o}.${"0".repeat(e)}`);return s?`-${o}`:o},o=(r,e)=>(r=r.normalize())instanceof f?r.round(e,t.RoundingMode.NEAREST_AWAY_FROM_ZERO):r,s=BigInt(0),u=BigInt(1),a=BigInt(2),c=BigInt(3),m=BigInt(4),d=BigInt(5),l=BigInt(10),h=BigInt(24);class f{constructor(t,r=0){if(this.type="fixed","bigint"==typeof t)this.number=t,this.decimalPos=r;else{const r=this.parseConstructorParameter(t);this.number=r.number,this.decimalPos=r.decimalPos}}parseConstructorParameter(t){if(t instanceof f)return{number:t.number,decimalPos:t.decimalPos};if(t instanceof g){if(!t.isInteger())throw new Error("Cannot create FixedNumber from non-integer Fraction");return{number:t.trunc().number,decimalPos:0}}if("number"==typeof t){if(!Number.isSafeInteger(t))throw new Error("The specified number cannot be exactly represented as an integer. Please provide a string instead.");return{number:BigInt(t),decimalPos:0}}if("string"==typeof t){if(0===(t=t.trim()).length)throw new Error("Empty string is not allowed");const r=t.match(/^(-?[0-9]*)(?:\.([0-9]*))?(?:[eE]([+-]?[0-9]+))?$/);if(!r)throw new Error(`Cannot parse number "${t}"`);let e=0,n=r[1]??"0";if(void 0!==r[2]&&(n+=r[2],e+=r[2].length),void 0!==r[3]){const t=Number(r[3]);t>0?n+="0".repeat(t):e-=t}return{number:BigInt(n),decimalPos:e}}throw new Error("Unsupported parameter!")}scaleNumber(t,r){const e=Math.max(this.decimalPos,r);return{a:e===this.decimalPos?this.number:this.number*l**BigInt(e-this.decimalPos),b:e===r?t:t*l**BigInt(e-r),decimalPos:e}}add(t){const r=w(t);if(r instanceof g)return r.add(this);const e=r,{a:n,b:i,decimalPos:o}=this.scaleNumber(e.number,e.decimalPos);return new f(n+i,o)}sub(t){const r=w(t);return this.add(r.neg())}mul(t){const r=w(t);if(r instanceof g)return r.mul(this);const e=r,n=this.number*e.number;return new f(n,this.decimalPos+e.decimalPos)}pow(t){const r=w(t).toNumber();if(!Number.isSafeInteger(r))throw new Error("Unsupported parameter");const e=Math.abs(r),n=new f(this.number**BigInt(e),this.decimalPos*e);return r<0?n.inv():n}powm(t,r,e){let n=w(t).toNumber();if(!Number.isSafeInteger(n))throw new Error("Unsupported parameter");const i=w(r);let o=this,s=new f(u);for(;0!==n;)n%2!=0&&(s=s.mul(o).mod(i,e)),o=o.pow(a).mod(i,e),n=Math.floor(n/2);return s}div(t){return this.convertToFraction().div(t)}divToInt(t){const r=w(t);if(r instanceof g)return this.convertToFraction().divToInt(r);const e=r,{a:n,b:i}=this.scaleNumber(e.number,e.decimalPos);return new f(n/i)}mod(r,e=t.ModType.TRUNCATED){const n=w(r);if(n instanceof g)return this.convertToFraction().mod(n);const i=n,{a:o,b:u,decimalPos:a}=this.scaleNumber(i.number,i.decimalPos),c=o%u,m=new f(c,a);if(e===t.ModType.TRUNCATED)return m;if(e===t.ModType.FLOORED)return Number(o<s)^Number(u<s)?m.add(u):m;if(e===t.ModType.EUCLIDEAN)return c<s?m.add(u<s?-u:u):m;throw new Error("Invalid ModType")}abs(){return new f(this.number<s?-this.number:this.number,this.decimalPos)}neg(){return this.mul(-u)}inv(){return this.convertToFraction().inv()}floor(r){return 0===this.decimalPos?this:this.round(r,t.RoundingMode.TO_NEGATIVE)}ceil(r){return 0===this.decimalPos?this:this.round(r,t.RoundingMode.TO_POSITIVE)}trunc(r){return 0===this.decimalPos?this:this.round(r,t.RoundingMode.TO_ZERO)}isTieStr(t){if("5"!==t[0])return!1;for(let r=1;r<t.length;r++)if("0"!==t[r])return!1;return!0}_round(r,e){const n=this.decimalPos-r;if(n<=0)return this;const i=l**BigInt(n),o=this.number/i;if(e===t.RoundingMode.TO_ZERO)return new f(o,r);const c=this.number%i;if(c===s)return new f(o,r);if(e===t.RoundingMode.AWAY_FROM_ZERO){const t=this.number<s?o-u:o+u;return new f(t,r)}if(e===t.RoundingMode.TO_POSITIVE){const t=this.number<s?o:o+u;return new f(t,r)}if(e===t.RoundingMode.TO_NEGATIVE){const t=this.number>=s?o:o-u;return new f(t,r)}if(![void 0,t.RoundingMode.NEAREST_TO_ZERO,t.RoundingMode.NEAREST_AWAY_FROM_ZERO,t.RoundingMode.NEAREST_TO_POSITIVE,t.RoundingMode.NEAREST_TO_NEGATIVE,t.RoundingMode.NEAREST_TO_EVEN].includes(e))throw new Error("Invalid rounding mode. Use the predefined values from the RoundingMode enum.");let m=(c<s?-c:c).toString();if(m.length<n&&(m="0"),this.isTieStr(m)){if(e===t.RoundingMode.NEAREST_TO_ZERO)return new f(o,r);if(e===t.RoundingMode.NEAREST_AWAY_FROM_ZERO){const t=this.number<s?o-u:o+u;return new f(t,r)}if(void 0===e||e===t.RoundingMode.NEAREST_TO_POSITIVE){const t=this.number<s?o:o+u;return new f(t,r)}if(e===t.RoundingMode.NEAREST_TO_NEGATIVE){const t=this.number>=s?o:o-u;return new f(t,r)}if(e===t.RoundingMode.NEAREST_TO_EVEN){if(o%a===s)return new f(o,r);return new f(o<s?o-u:o+u,r)}}if(Number(m[0])<5)return new f(o,r);const d=this.number<s?o-u:o+u;return new f(d,r)}round(t,r){if(t=void 0===t?0:t,!Number.isSafeInteger(t)||t<0)throw new Error("Invalid value for decimals");return this._round(t,r).normalize()}_incExponent(t){if(0===t)return this;let r=this.number,e=this.decimalPos;if(t<0)e-=t;else{const n=Math.min(t,this.decimalPos);e-=n;const i=t-n;i>0&&(r*=l**BigInt(i))}return new f(r,e)}countDigits(){if(this.number===s)return 1;let t=0,r=this.number<s?-this.number:this.number;for(;r>s;)r/=l,t++;return t}toSubZeroNum(){const t=this.countDigits();return{subZeroNum:new f(this.number,t),exponentDiff:t-this.decimalPos}}roundToDigits(t,r){if(!Number.isSafeInteger(t)||t<1)throw new Error("Invalid value for digits");const{subZeroNum:e,exponentDiff:n}=this.toSubZeroNum();let i=e.round(t,r);return i=i._incExponent(n),i}intPart(){return this.trunc()}fracPart(){return this.sub(this.trunc())}sign(){return this.number<s?-1:1}bitwiseAnd(t){if(t=b(t),!this.isInteger()||-1===this.sign()||!t.isInteger()||-1===t.sign())throw new Error("Only positive integers are supported");t instanceof g&&(t=t.trunc());const r=a**h;let e=this.normalize().number,n=t.trunc().normalize().number,i=s,o=u;for(;e>s&&n>s;){const t=BigInt.asUintN(24,e),s=BigInt.asUintN(24,n);i+=BigInt(Number(t)&Number(s))*o,o*=r,e/=r,n/=r}return new f(i)}bitwiseOr(t){if(t=b(t),!this.isInteger()||-1===this.sign()||!t.isInteger()||-1===t.sign())throw new Error("Only positive integers are supported");t instanceof g&&(t=t.trunc());const r=a**h;let e=this.normalize().number,n=t.trunc().normalize().number,i=s,o=u;for(;e>s||n>s;){const t=BigInt.asUintN(24,e),s=BigInt.asUintN(24,n);i+=BigInt(Number(t)|Number(s))*o,o*=r,e/=r,n/=r}return new f(i)}bitwiseXor(t){if(t=b(t),!this.isInteger()||-1===this.sign()||!t.isInteger()||-1===t.sign())throw new Error("Only positive integers are supported");t instanceof g&&(t=t.trunc());const r=a**h;let e=this.normalize().number,n=t.trunc().normalize().number,i=s,o=u;for(;e>s||n>s;){const t=BigInt.asUintN(24,e),s=BigInt.asUintN(24,n);i+=BigInt(Number(t)^Number(s))*o,o*=r,e/=r,n/=r}return new f(i)}shiftLeft(t){if(!this.isInteger()||-1===this.sign())throw new Error("Only positive integers are supported");if(!Number.isSafeInteger(t)||t<0)throw new Error("Invalid value for bitCount");const r=a**BigInt(t);return this.mul(r)}shiftRight(t){if(!this.isInteger()||-1===this.sign())throw new Error("Only positive integers are supported");if(!Number.isSafeInteger(t)||t<0)throw new Error("Invalid value for bitCount");const r=a**BigInt(t);return new f(this.normalize().number/r)}cmp(t){const r=w(t);if(r instanceof g)return-r.cmp(this);const e=r,{a:n,b:i}=this.scaleNumber(e.number,e.decimalPos);return n===i?0:n>i?1:-1}eq(t){return 0===this.cmp(t)}lt(t){return-1===this.cmp(t)}lte(t){return this.cmp(t)<=0}gt(t){return 1===this.cmp(t)}gte(t){return this.cmp(t)>=0}clamp(t,r){const e=b(t),n=b(r);if(e.gt(n))throw new Error("Min parameter has to be smaller than max");return this.lt(e)?e:this.gt(n)?n:this}isZero(){return this.number===s}isOne(){if(0===this.decimalPos)return this.number===u;const t=l**BigInt(this.decimalPos),r=this.number/t;return r===u&&r*t===this.number}isInteger(){return 0===this.decimalPos||this.number%l**BigInt(this.decimalPos)===s}serialize(){return[this.number,this.decimalPos]}getFractionParts(t=!0){return this.convertToFraction().getFractionParts(t)}normalize(){if(0===this.decimalPos)return this;let t=this.decimalPos,r=this.number;for(;t>0&&r%l===s;)t--,r/=l;return new f(r,t)}convertToFraction(){if(0===this.decimalPos)return new g(this.number,u);const t=l**BigInt(this.decimalPos);return new g(this.number,t)}toNumber(){return Number(this.toPrecision(20))}toFixed(r,e=t.RoundingMode.TO_ZERO,n=!1){if(!Number.isSafeInteger(r)||r<0)throw new Error("Invalid parameter");const o=this._round(r,e);return i(o.number,o.decimalPos,r,n)}toExponential(r,e=t.RoundingMode.TO_ZERO,i=!1){if(!Number.isSafeInteger(r)||r<0)throw new Error("Invalid parameter");const o=this.roundToDigits(r+1,e).normalize(),s=-1===o.sign(),u=o.abs(),a=u.number.toString(),c=a.length<=r?`${a}${"0".repeat(r-a.length+1)}`:a.slice(0,r+1);let m=c;c.length>1&&(m=`${c.slice(0,1)}.${c.slice(1)}`,i&&(m=n(m)));const d=u.decimalPos,l=a.length-1-d;return`${s?"-":""}${m}e${l>=0?"+":""}${l}`}toBase(t,r){if(!Number.isSafeInteger(t)||t<2||t>16)throw new Error("Invalid radix");if(void 0!==r&&(!Number.isSafeInteger(r)||r<0))throw new Error("Invalid parameter");const e=this.normalize();if(0===e.decimalPos)return e.number.toString(t);const n=void 0===r?Number.MAX_SAFE_INTEGER:r;let i=e.intPart(),o=e.sub(i);const s=-1===e.sign();s&&(i=i.neg(),o=o.neg());const u=new Map;let a=[];for(;!o.isZero();){const r=o.mul(t),e=r.toString(),i=u.get(e);if(void 0!==i){a=[...a.slice(0,i-1),"(",...a.slice(i-1),")"];break}if(a.length===n)break;const s=Math.abs(r.intPart().toNumber());a.push(s.toString(t)),o=r.fracPart(),u.set(e,a.length)}const c=a.join("");return`${s?"-":""}${i.number.toString(t)}${a.length?".":""}${c}`}toFraction(){return this.convertToFraction().toFraction()}toString(t,r){if(void 0===t||10===t){const t=void 0!==r?this.trunc(r):this;return i(t.number,t.decimalPos,t.decimalPos,!0)}return this.toBase(t,r)}toPrecision(r,e=t.RoundingMode.TO_ZERO,o=!1){if(!Number.isSafeInteger(r)||r<1)throw new Error("Invalid parameter");const s=this.roundToDigits(r,e),{subZeroNum:u,exponentDiff:a}=s.toSubZeroNum(),c=-1===u.sign();let m=i(u.number,u.decimalPos,u.decimalPos,!1);m=m.slice(c?3:2),m=m.slice(0,Math.max(r,a));const d=m.slice(0,Math.max(0,a)),l=m.slice(Math.max(0,a)),h=Math.max(0,r-d.length-l.length),f="0".repeat(a<0?-a:0);let g=d||"0";if(l.length+f.length+h>0){g+=`.${f}${l}${"0".repeat(h)}`,o&&(g=n(g))}return c?`-${g}`:g}valueOf(){throw new Error("Unsafe conversion to Number type! Use toNumber() instead.")}}class g{constructor(t,r){if(this.type="fraction","bigint"==typeof t&&"bigint"==typeof r)this.numerator=t,this.denominator=r;else{const e=this.parseParameter(t),n=this.parseParameter(r),i=e.div(n),o=i instanceof f?i.convertToFraction():i;this.numerator=o.numerator,this.denominator=o.denominator}if(this.denominator===s)throw new Error("Division by zero")}parseRepeatingDecimal(t){if(!t.includes("("))return new f(t).convertToFraction();const r=(t=t.trim()).match(/^(-?[0-9]*)\.([0-9]+)?\(([0-9]+)\)(?:[eE]([+-]?[0-9]+))?$/);if(!r)throw new Error(`Cannot parse string "${t}"`);const e="-"===r[1]?"-0":r[1],n=r[2]??"",i=r[3],o=r[4],s=BigInt(e+n+i)-BigInt(e+n),u=BigInt("9".repeat(i.length)+"0".repeat(n.length)),a=new g(s,u);if(void 0!==o){const t=o.startsWith("-"),r=l**BigInt(t?o.slice(1):o);return t?a.div(r).normalize():a.mul(r).normalize()}return a.simplify()}parseParameter(t){if(t instanceof g)return t;if(t instanceof f)return t.convertToFraction();if("number"==typeof t){if(!Number.isSafeInteger(t))throw new Error("Floating point values as numbers are unsafe. Please provide them as a string.");return new g(BigInt(t),u)}if("bigint"==typeof t)return new g(t,u);if("string"==typeof t){const r=t.split("/");if(r.length>2)throw new Error(`Cannot parse string '${t}'`);const e=this.parseRepeatingDecimal(r[0]),n=r[1]?this.parseRepeatingDecimal(r[1]):new g(u,u);return e.div(n).convertToFraction()}throw new Error("Unsupported parameter!")}add(t){const{numerator:r,denominator:e}=this.parseParameter(t);return this.denominator===e?new g(this.numerator+r,this.denominator):new g(this.numerator*e+r*this.denominator,e*this.denominator)}sub(t){const{numerator:r,denominator:e}=this.parseParameter(t);return this.add(new g(-r,e))}mul(t){const{numerator:r,denominator:e}=this.parseParameter(t);return new g(this.numerator*r,this.denominator*e)}div(t){const{numerator:r,denominator:e}=this.parseParameter(t);return this.mul(new g(e,r))}divToInt(t){return this.div(t).trunc()}mod(r,e=t.ModType.TRUNCATED){const n=this.parseParameter(r),i=n.denominator*this.numerator%(n.numerator*this.denominator),o=this.denominator*n.denominator,s=new g(i,o);if(e===t.ModType.TRUNCATED)return s;if(e===t.ModType.FLOORED)return Number(-1===this.sign())^Number(-1===n.sign())?s.add(n):s;if(e===t.ModType.EUCLIDEAN)return-1===s.sign()?s.add(-1===n.sign()?n.neg():n):s;throw new Error("Invalid ModType")}pow(t){const r=this.parseParameter(t);if(!r.isInteger())throw new Error("Unsupported parameter");const e=r.numerator/r.denominator,n=e<s?-e:e,i=new g(this.numerator**n,this.denominator**n);return e<s?i.inv():i}powm(t,r,e){const n=this.parseParameter(t);if(!n.isInteger())throw new Error("Unsupported parameter");let i=n.toNumber();const o=this.parseParameter(r);let s=this,c=new g(u,u);for(;0!==i;)i%2!=0&&(c=c.mul(s).mod(o,e)),s=s.pow(a).mod(o,e),i=Math.floor(i/2);return c}inv(){return new g(this.denominator,this.numerator)}floor(r){return this.denominator===u?new f(this.numerator):this.round(r,t.RoundingMode.TO_NEGATIVE)}ceil(r){return this.denominator===u?new f(this.numerator):this.round(r,t.RoundingMode.TO_POSITIVE)}trunc(r){return this.denominator===u?new f(this.numerator):this.round(r,t.RoundingMode.TO_ZERO)}round(t,r){if(t=void 0===t?0:t,!Number.isSafeInteger(t)||t<0)throw new Error("Invalid value for decimals");const e=this.toFixedNumber(t+1);if(this.sub(e).isZero())return e.round(t,r);return new f(`${e.toFixed(t+1)}1`).round(t,r)}roundToDigits(t,r){if(!Number.isSafeInteger(t)||t<1)throw new Error("Invalid value for digits");if(this.isZero())return new f(s);let e=this.abs(),n=0;for(;e.gte(u);)e=e.div(l),n++;const i=new g(u,l);for(;e.lt(i);)e=e.mul(l),n--;let o=e.round(t,r);return o=o._incExponent(n),-1===this.sign()?o.neg():o}gcd(t,r){let e=t<s?-t:t,n=r<s?-r:r;if(n>e){const t=e;e=n,n=t}for(;;){if(n===s)return e;if(e%=n,e===s)return n;n%=e}}simplify(){let{numerator:t,denominator:r}=this;const e=this.gcd(t,r);return e>u&&(t/=e,r/=e),r<s&&(t=-t,r=-r),new g(t,r)}normalize(){const{numerator:r,denominator:e}=this.simplify();if(e===u)return new f(r,0);const n=new g(r,e),{cycleLen:i,cycleStart:o}=n.getDecimalFormat(0);return 0!==i?n:n.round(o,t.RoundingMode.TO_ZERO)}getFractionParts(t=!0){const r=t?this.simplify():this;return{numerator:new f(r.numerator),denominator:new f(r.denominator)}}sign(){return(this.numerator<s?-1:1)*(this.denominator<s?-1:1)}abs(){return new g(this.numerator<s?-this.numerator:this.numerator,this.denominator<s?-this.denominator:this.denominator)}neg(){return this.mul(-u)}intPart(){return this.trunc()}fracPart(){return this.sub(this.trunc())}cmp(t){const r=this.parseParameter(t),e=this.denominator===r.denominator,n=e?this.numerator:this.numerator*r.denominator,i=e?r.numerator:r.numerator*this.denominator;return n===i?0:n>i?1:-1}eq(t){return 0===this.cmp(t)}lt(t){return-1===this.cmp(t)}lte(t){return this.cmp(t)<=0}gt(t){return 1===this.cmp(t)}gte(t){return this.cmp(t)>=0}clamp(t,r){const e=b(t),n=b(r);if(e.gt(n))throw new Error("Min parameter has to be smaller than max");return this.lt(e)?e:this.gt(n)?n:this}isZero(){return this.numerator===s}isOne(){return this.numerator===this.denominator}isInteger(){return this.numerator%this.denominator===s}serialize(){return[this.numerator,this.denominator]}toNumber(){return Number(this.toPrecision(20))}convertToFraction(){return this}getNumberForBitwiseOp(){if(!this.isInteger()||-1===this.sign())throw new Error("Only positive integers are supported");return this.intPart()}bitwiseAnd(t){return this.getNumberForBitwiseOp().bitwiseAnd(t)}bitwiseOr(t){return this.getNumberForBitwiseOp().bitwiseOr(t)}bitwiseXor(t){return this.getNumberForBitwiseOp().bitwiseXor(t)}shiftLeft(t){return this.getNumberForBitwiseOp().shiftLeft(t)}shiftRight(t){return this.getNumberForBitwiseOp().shiftRight(t)}getDecimalFormat(t){t=void 0===t?Number.MAX_SAFE_INTEGER:t;let r=this.denominator<s?-this.denominator:this.denominator,e=0;for(;r%a===s;)r/=a,e++;let n=0;for(;r%d===s;)r/=d,n++;const i=Math.max(e,n);if(r===u)return{cycleLen:0,cycleStart:i};const o=Math.max(1,t-i);let c=l%r,m=1;for(;c!==u;){if(m===o)return{cycleLen:null,cycleStart:i};c=c*l%r,m++}return{cycleLen:m,cycleStart:i}}toFixed(r,e=t.RoundingMode.TO_ZERO,n=!1){if(!Number.isSafeInteger(r)||r<0)throw new Error("Invalid parameter");return this.round(r,e).toFixed(r,t.RoundingMode.TO_ZERO,n)}toRepeatingParts(t){if(this.isZero())return["0","",""];const{cycleLen:r,cycleStart:e}=this.simplify().getDecimalFormat(t);if(null===r||0===r){const r=t??e,i=this.toFixed(r),o=n(i).split(".");return[o[0],o[1]??"",""]}const i=e+r,o=this.toFixed(i).split(".");return[o[0],o[1].slice(0,e),o[1].slice(e)]}toRepeatingDigits(t){const r=this.toRepeatingParts(t);let e=r[0];return(r[1]||r[2])&&(e+=`.${r[1]}`),r[2]&&(e+=`(${r[2]})`),e}toExponential(r,e=t.RoundingMode.TO_ZERO,n=!1){if(!Number.isSafeInteger(r)||r<0)throw new Error("Invalid parameters");return this.toFixedNumber(r).toExponential(r,e,n)}toFraction(){const{numerator:t,denominator:r}=this.getFractionParts(!0);return`${t.toString()}/${r.toString()}`}toFixedNumber(t){const r=this.numerator*l**BigInt(t);return new f(r/this.denominator,t)}toBase(t,r){if(!Number.isSafeInteger(t)||t<2||t>16)throw new Error("Invalid radix");if(void 0!==r&&(!Number.isSafeInteger(r)||r<0))throw new Error("Invalid parameter");if(10===t)return void 0===r?this.toRepeatingDigits(r):n(this.toFixed(r));const e=this.normalize(),i=void 0===r?Number.MAX_SAFE_INTEGER:r+1;let o=e.intPart(),s=e.sub(o);const u=-1===e.sign();u&&(o=o.neg(),s=s.neg());const a=new Map;let c=[];for(;!s.isZero()&&c.length!==i;){const r=s.mul(t),e=r.normalize().toFraction(),n=a.get(e);if(void 0!==n){c=[...c.slice(0,n-1),"(",...c.slice(n-1),")"];break}const i=Math.abs(r.intPart().toNumber());c.push(i.toString(t)),s=r.fracPart(),a.set(e,c.length)}c.length===i&&c.pop();const m=c.join("");return`${u?"-":""}${o.toString(t)}${c.length?".":""}${m}`}toString(t,r){return void 0===t||10===t?this.toRepeatingDigits(r):this.toBase(t,r)}toPrecision(r,e=t.RoundingMode.TO_ZERO,n=!1){if(!Number.isSafeInteger(r)||r<1)throw new Error("Invalid parameter");return this.roundToDigits(r,e).toPrecision(r,t.RoundingMode.TO_ZERO,n)}valueOf(){throw new Error("Unsafe conversion to Number type! Use toNumber() instead.")}}function w(t){if(t instanceof f||t instanceof g)return t;if("bigint"==typeof t)return new f(t);if("number"==typeof t){if(!Number.isSafeInteger(t))throw new Error("Floating point values as numbers are unsafe. Please provide them as a string.");return new f(t)}if("string"==typeof t)return t.includes("/")||t.includes("(")?new g(t,u):new f(t);throw new Error("Unsupported parameter type")}const b=(t,r)=>{if(void 0===t)throw new Error("First parameter cannot be undefined");const e=w(t);if(void 0===r)return e;const n=w(r);return new g(e,u).div(new g(n,u))};b.min=(...t)=>{if(0===t.length)throw new Error("Got empty array");let r=b(t[0]);for(let e=1;e<t.length;e++){const n=b(t[e]);n.lt(r)&&(r=n)}return r},b.max=(...t)=>{if(0===t.length)throw new Error("Got empty array");let r=b(t[0]);for(let e=1;e<t.length;e++){const n=b(t[e]);n.gt(r)&&(r=n)}return r};const p=(t,r)=>{let e=s;for(let n=0;n<t.length;n++){const i=t.charAt(n),o=parseInt(i,r);if(Number.isNaN(o))throw new Error(`Invalid digit "${i}"`);e*=BigInt(r),e+=BigInt(o)}return e};b.fromBase=(t,r)=>{if("string"!=typeof t)throw new Error("First parameter must be string");if(!Number.isSafeInteger(r)||r<2||r>16)throw new Error("Invalid radix");if(10===r)return b(t);if(0===(t=t.trim()).length)throw new Error("Empty string is not allowed");const e=t.startsWith("-");e&&(t=t.slice(1));const n=t.match(/^([0-9a-f]*)(?:\.([0-9a-f]*)(?:\(([0-9a-f]+)\))?)?$/i);if(!n)throw new Error(`Cannot parse number "${t}"`);const i=n[1]??"",o=n[2]??"",s=n[3]??"";if(s.length>0){const t=p(`${i}${o}${s}`,r)-p(`${i}${o}`,r),n=p((r-1).toString(r).repeat(s.length)+"0".repeat(o.length),r),u=new g(t,n).normalize();return e?u.neg():u}const a=p(i,r),c=p(o,r),m=new g(c,BigInt(r)**BigInt(o.length)),d=new g(a,u).add(m).normalize();return e?d.neg():d},b.range=function*(t,r,e){const n=b(r),i=b(e??1);let o=b(t);for(;o.lt(n);)yield o,o=o.add(i)},b.gcd=(t,r)=>{const e=b(t).abs(),n=b(r).abs();let i=n.gt(e)?n:e,o=i.eq(e)?n:e;for(;;){if(o.isZero())return i;if(i=i.mod(o),i.isZero())return o;o=o.mod(i)}},b.lcm=(t,r)=>{const e=b(t).abs(),n=b(r).abs(),i=e.mul(n);if(i.isZero())throw new Error("LCM of zero is undefined");const o=b.gcd(e,n);return i.div(o)};const E=(t,r,e)=>{const n=((t,r)=>{let e=r.toNumber();if(Number.isFinite(e)){const r=e<0;r&&(e=-e);let n=e**(1/t);return r&&(n=-n),n.toString()}const n=r.abs().toFixed(0).length,i=Math.ceil(n/t);return`${1===r.sign()?"":"-"}5e${i}`})(t,r);let i=new f("0"!==n?n:"1");const o=new g(t-1,t),s=new g(r,t),u=BigInt(t-1);let a=i.trunc(e+5);for(;i=o.mul(i).add(s.mul(i.pow(u).inv())),i=i.trunc(e+5),!i.isZero()&&!a.eq(i);)a=i;return i.trunc(e)},I=(t,r,e)=>{if(!Number.isSafeInteger(t))throw new Error("Integer is expected for N");if(t<0)throw new Error("Negative N is not supported");if(0===t)throw new Error("N cannot be zero");const n=o(b(r),e);if(1===t)return n.trunc(e);if(t%2==0&&-1===n.sign())throw new Error("Complex numbers are not supported");if(n.isZero())return new f(s).trunc(e);if(n.isOne())return new f(u).trunc(e);return E(t,n,e)},N=(t,r)=>I(2,t,r);class v{constructor(t,r){this.cachedDecimals=0,this.fn=t,this.max=r}get(t){if(t<=this.cachedDecimals)return this.cache.trunc(t);const r=new f(this.fn(t)),e=Math.min(this.max,t);return this.cachedDecimals!==e&&(this.cache=r.trunc(e),this.cachedDecimals=e),r}}const T=(t,r)=>{let e=o(b(t),r);if(e.isOne())return new f(0).trunc(r);if(e.lte(0))throw new Error("Invalid parameter");let n=0;const i=b("0.1");for(;e.sub(u).abs().gt(i);)e=new f(N(e,r+10)),n++;const c=function*(t,r){const e=t.pow(a).normalize();let n=t,i=u,o=b(t);for(;;){n=n.mul(e),i+=a;const t=n.div(i).trunc(r+10);o=o.add(t),yield{term:t,sum:o}}}(e.sub(u).div(e.add(u)),r);for(const{term:t,sum:e}of c)if(t.isZero()){return e.mul(a**BigInt(n+1)).trunc(r)}return b(s)},O=new v((t=>T(a,t)),200),R=new v((t=>T(l,t)),200);const P=(t,r)=>{const e=o(b(t),r),n=b(`1e-${r+5}`),i=function*(t,r){let e=t.add(1),n=BigInt(6),i=m;const o=t.pow(a);let s=o;for(;;){const c=s.mul(t.add(i-u)).div(n);n*=i*(i+u),i+=a,s=s.mul(o),e=e.add(c).trunc(r+5),yield{term:c,sum:e}}}(e,r);for(const{term:t,sum:e}of i)if(t.abs().lt(n))return e.trunc(r);return b(s)},_=new v((t=>{if(0===t)return b(c);let r=u,e=c*l**BigInt(t+20),n=e;for(;e!==s;)e=e*r/((r+u)*m),r+=a,n+=e/r;return b(`3.${n.toString().slice(1,t+1)}`)}),1e3),S=t=>0===t?b(c):_.get(t).trunc(t),M=(r,e)=>{let n=r.round(e+5,t.RoundingMode.NEAREST_AWAY_FROM_ZERO);const i=S(e+5),o=((t,r,e)=>{const n=Math.max(3,e),i=t.trunc(n),o=i.div(r).round();return r.mul(o).trunc(n).eq(i)?o:null})(n,i.div(12),e);if(null!==o)return(t=>{let r=t.mod(h).toNumber();r<0&&(r+=24);const e=Math.floor(r/6)+1;let n=15*r;return 4===e?n=360-n:3===e?n-=180:2===e&&(n=180-n),{specialCaseDeg:n,quadrant:e,subHalfPiAngle:null}})(o);const s=i.mul(a);n=n.mod(s),-1===n.sign()&&(n=n.add(s));const u=n.mul(a).div(i).floor().toNumber()+1;let c=n;return 4===u?c=s.sub(c):3===u?c=c.sub(i):2===u&&(c=i.sub(c)),{specialCaseDeg:null,quadrant:u,subHalfPiAngle:c}};const A=(t,r,e)=>{let n=b(t);return r&&(n=n.neg()),n.trunc(e)},y=(t,r,e)=>{let n;if(0===t)n=u;else if(30===t)n=b(N(c,e+5)).div(a);else if(45===t)n=b(N(a,e+5)).div(a);else if(60===t)n="0.5";else{if(90!==t)throw new Error;n=s}return A(n,r,e)},F=(r,e)=>{const n=e+10,i=o(b(r),e+5),{specialCaseDeg:s,subHalfPiAngle:m,quadrant:d}=M(i,e),l=2===d||3===d;if(null!==s)return y(s,l,e);const h=b(`1e-${n}`),f=function*(r,e){const n=r.round(e+10,t.RoundingMode.NEAREST_AWAY_FROM_ZERO).pow(a);let i=n,o=a,s=b(u).sub(i.div(o).trunc(e+10)),m=c;for(;;){o*=m*(m+u),m+=a;const t=m*(m+u);m+=a,i=i.mul(n),o*=t;let r=i.mul(t);i=i.mul(n),r=r.sub(i);const c=r.div(o).trunc(e+10);s=s.add(c),yield{term:c,sum:s}}}(m,e);for(const{term:t,sum:r}of f)if(t.lt(h))return A(r,l,e);return b(0)};const B=(t,r)=>{let e=o(b(t),r);if(e.isZero())return b(0);if(e.abs().isOne())return b(S(r)).div(4*e.sign()).trunc(r);let n=0;const i=b("0.42");for(;e.abs().gt(i);){const t=b(N(e.pow(a).add(u),r+10));e=e.div(t.add(u)),n++}const s=b(`1e-${r+10}`),m=function*(t,r){const e=t.pow(a).normalize(),n=e.pow(a).normalize();let i=c,o=t.sub(t.mul(e).div(i)),s=t.mul(n);for(;;){i+=a;const t=i+a,u=s.mul(e.mul(-i).add(t)).div(i*t);i=t,s=s.mul(n),o=o.add(u).trunc(r+10),yield{term:u,sum:o}}}(e,r);for(const{term:t,sum:e}of m)if(t.abs().lt(s)){return e.mul(a**BigInt(n)).trunc(r)}return b(0)},Z=(t,r)=>{const e=o(b(t),r);if(e.isZero())return b(s);if(e.abs().isOne())return b(S(r)).mul(e.sign()).div(a).trunc(r);if(e.abs().eq("1/2"))return b(S(r)).mul(e.sign()).div(6).trunc(r);if(e.gt(u)||e.lt(-u))throw new Error("Out of range");const n=b(N(e.pow(a).neg().add(u),r+10));return b(B(e.div(n.add(u)),r+10)).mul(a).trunc(r)};const $=(t,r)=>{const e=o(b(t),r),n=new f(`1e-${r+5}`),i=function*(t,r){const e=t.pow(a).normalize();let n=e,i=a,o=n.div(i).add(u).trunc(r+5),s=c;for(;;){n=n.mul(e),i*=s*(s+u),s+=a;const t=n.div(i);o=o.add(t).trunc(r+5),yield{term:t,sum:o}}}(e,r);for(const{term:t,sum:e}of i)if(t.abs().lt(n))return e.trunc(r);return b(s)};t.ExactNumber=b,t.PI=S,t.acos=(t,r)=>{const e=o(b(t),r);if(e.isZero())return b(S(r)).div(a).trunc(r);if(e.isOne())return b(s);if(e.abs().isOne())return S(r);if(e.abs().eq("1/2")){const t=b(S(r)).div(c);return-1===e.sign()?t.mul(a).trunc(r):t.trunc(r)}if(e.gt(u)||e.lt(-u))throw new Error("Out of range");return b(S(r+10)).div(a).sub(Z(e,r+10)).trunc(r)},t.acosh=(t,r)=>{const e=o(b(t),r);if(e.isOne())return b(s);if(e.lt(u))throw new Error("Out of range");const n=N(e.pow(a).sub(u),r+5);return T(e.add(n),r+5).trunc(r)},t.asin=Z,t.asinh=(t,r)=>{const e=o(b(t),r);if(e.isZero())return b(s);const n=N(e.pow(a).add(u),r+5);return T(e.add(n),r+5).trunc(r)},t.atan=B,t.atanh=(t,r)=>{const e=o(b(t),r);if(e.abs().gte(u))throw new Error("Out of range");if(e.isZero())return b(s);const n=T(e.add(u).div(e.neg().add(u)),r+5);return b(n).div(a).trunc(r)},t.cbrt=(t,r)=>I(3,t,r),t.cos=F,t.cosh=$,t.exp=P,t.log=T,t.log10=(t,r)=>new f(T(t,r+10)).div(R.get(r+10)).trunc(r),t.log2=(t,r)=>new f(T(t,r+10)).div(O.get(r+10)).trunc(r),t.logn=(t,r,e)=>{if(!Number.isSafeInteger(t)||t<2)throw new Error("Invalid parameter for N");const n=T(r,e+10),i=T(t,e+10);return new f(n).div(i).trunc(e)},t.nthroot=I,t.pow=(t,r,e)=>{const n=o(b(t),e),i=o(b(r),e);if(i.isInteger()&&Number.isSafeInteger(i.toNumber()))return n.pow(i).trunc(e);if(-1===n.sign()&&!i.isInteger())throw new Error("Complex numbers are not supported");const s=T(n,e+5),u=i.mul(s);return P(u,e+5).trunc(e)},t.sin=(t,r)=>{const e=o(b(t),r+5),{specialCaseDeg:n,quadrant:i}=M(e,r);if(null!==n)return y(90-n,3===i||4===i,r);const s=new f(S(r+5));return F(s.div(a).sub(e),r+5).trunc(r)},t.sinh=(t,r)=>{const e=o(b(t),r),n=new f(`1e-${r+5}`),i=function*(t,r){let e=t,n=u;const i=t.pow(a).normalize();let o=t.trunc(r+5),s=a;for(;;){e=e.mul(i),n*=s*(s+u),s+=a;const t=e.div(n);o=o.add(t).trunc(r+5),yield{term:t,sum:o}}}(e,r);for(const{term:t,sum:e}of i)if(t.abs().lt(n))return e.trunc(r);return b(s)},t.sqrt=N,t.tan=(t,r)=>{const e=o(b(t),r+5),{specialCaseDeg:n,quadrant:i,subHalfPiAngle:s}=M(e,r),m=2===i||4===i;if(null!==n){if(0===n)return A("0",m,r);if(30===n)return A(b(u).div(N(c,r+5)),m,r);if(45===n)return A("1",m,r);if(60===n)return A(N(c,r+5),m,r);if(90===n)throw new Error("Out of range");throw new Error}const d=b(F(s.mul(a),r+5)),l=b(u).sub(d).div(b(u).add(d)).round(r+5),h=N(l,r+5).trunc(r);return m?h.neg():h},t.tanh=(t,r)=>{const e=o(b(t),r);if(e.isZero())return b(s);const n=$(e,r+10).abs();return N(n.pow(a).sub(u),r+10).div(n).mul(e.sign()).trunc(r)}}));
