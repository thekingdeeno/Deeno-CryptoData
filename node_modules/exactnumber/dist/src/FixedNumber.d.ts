import { Fraction } from './Fraction';
import { ExactNumberType, ModType, RoundingMode } from './types';
export declare class FixedNumber implements ExactNumberType {
    readonly type = "fixed";
    private readonly number;
    private decimalPos;
    private parseConstructorParameter;
    constructor(x: number | bigint | string | ExactNumberType, decimalPos?: number);
    private scaleNumber;
    add(x: number | bigint | string | ExactNumberType): ExactNumberType;
    sub(x: number | bigint | string | ExactNumberType): ExactNumberType;
    mul(x: number | bigint | string | ExactNumberType): ExactNumberType;
    pow(x: number | bigint | string | ExactNumberType): ExactNumberType;
    powm(_exp: number | bigint | string | ExactNumberType, _mod: number | bigint | string | ExactNumberType, modType?: ModType): FixedNumber;
    div(x: number | bigint | string | ExactNumberType): ExactNumberType;
    divToInt(x: number | bigint | string | ExactNumberType): ExactNumberType;
    mod(x: number | bigint | string | ExactNumberType, type?: ModType): ExactNumberType;
    abs(): FixedNumber;
    neg(): FixedNumber;
    inv(): ExactNumberType;
    floor(decimals?: number): FixedNumber;
    ceil(decimals?: number): FixedNumber;
    trunc(decimals?: number): FixedNumber;
    private isTieStr;
    private _round;
    round(decimals?: number, roundingMode?: RoundingMode): FixedNumber;
    _incExponent(amount: number): FixedNumber;
    private countDigits;
    private toSubZeroNum;
    roundToDigits(digits: number, roundingMode: RoundingMode): FixedNumber;
    intPart(): ExactNumberType;
    fracPart(): ExactNumberType;
    sign(): -1 | 1;
    bitwiseAnd(x: number | bigint | string | ExactNumberType): ExactNumberType;
    bitwiseOr(x: number | bigint | string | ExactNumberType): ExactNumberType;
    bitwiseXor(x: number | bigint | string | ExactNumberType): ExactNumberType;
    shiftLeft(bitCount: number): ExactNumberType;
    shiftRight(bitCount: number): ExactNumberType;
    cmp(x: number | bigint | string | ExactNumberType): -1 | 0 | 1;
    eq(x: number | bigint | string | ExactNumberType): boolean;
    lt(x: number | bigint | string | ExactNumberType): boolean;
    lte(x: number | bigint | string | ExactNumberType): boolean;
    gt(x: number | bigint | string | ExactNumberType): boolean;
    gte(x: number | bigint | string | ExactNumberType): boolean;
    clamp(min: number | bigint | string | ExactNumberType, max: number | bigint | string | ExactNumberType): ExactNumberType;
    isZero(): boolean;
    isOne(): boolean;
    isInteger(): boolean;
    serialize(): [bigint, number];
    getFractionParts(normalize?: boolean): {
        numerator: FixedNumber;
        denominator: FixedNumber;
    };
    normalize(): FixedNumber;
    convertToFraction(): Fraction;
    toNumber(): number;
    toFixed(decimals: number, roundingMode?: RoundingMode, trimZeros?: boolean): string;
    toExponential(digits: number, roundingMode?: RoundingMode, trimZeros?: boolean): string;
    private toBase;
    toFraction(): string;
    toString(radix?: number, maxDigits?: number): string;
    toPrecision(digits: number, roundingMode?: RoundingMode, trimZeros?: boolean): string;
    valueOf(): number;
}
