import { ExactNumberType, ModType, RoundingMode } from './types';
import { FixedNumber } from './FixedNumber';
export declare class Fraction implements ExactNumberType {
    readonly type = "fraction";
    private readonly numerator;
    private readonly denominator;
    private parseRepeatingDecimal;
    private parseParameter;
    constructor(x: number | bigint | string | ExactNumberType, y: number | bigint | string | ExactNumberType);
    add(x: number | bigint | string | ExactNumberType): ExactNumberType;
    sub(x: number | bigint | string | ExactNumberType): ExactNumberType;
    mul(x: number | bigint | string | ExactNumberType): ExactNumberType;
    div(x: number | bigint | string | ExactNumberType): ExactNumberType;
    divToInt(x: number | bigint | string | ExactNumberType): ExactNumberType;
    mod(r: number | bigint | string | ExactNumberType, type?: ModType): ExactNumberType;
    pow(x: number | bigint | string | ExactNumberType): ExactNumberType;
    powm(_exp: number | bigint | string | ExactNumberType, _mod: number | bigint | string | ExactNumberType, modType?: ModType): ExactNumberType;
    inv(): ExactNumberType;
    floor(decimals?: number): FixedNumber;
    ceil(decimals?: number): FixedNumber;
    trunc(decimals?: number): FixedNumber;
    round(decimals?: number, roundingMode?: RoundingMode): FixedNumber;
    roundToDigits(digits: number, roundingMode: RoundingMode): FixedNumber;
    private gcd;
    private simplify;
    normalize(): FixedNumber | Fraction;
    getFractionParts(normalize?: boolean): {
        numerator: FixedNumber;
        denominator: FixedNumber;
    };
    sign(): -1 | 1;
    abs(): ExactNumberType;
    neg(): ExactNumberType;
    intPart(): FixedNumber;
    fracPart(): ExactNumberType;
    cmp(x: number | bigint | string | ExactNumberType): -1 | 0 | 1;
    eq(x: number | bigint | string | ExactNumberType): boolean;
    lt(x: number | bigint | string | ExactNumberType): boolean;
    lte(x: number | bigint | string | ExactNumberType): boolean;
    gt(x: number | bigint | string | ExactNumberType): boolean;
    gte(x: number | bigint | string | ExactNumberType): boolean;
    clamp(min: number | bigint | string | ExactNumberType, max: number | bigint | string | ExactNumberType): ExactNumberType;
    isZero(): boolean;
    isOne(): boolean;
    isInteger(): boolean;
    serialize(): [bigint, bigint];
    toNumber(): number;
    convertToFraction(): this;
    private getNumberForBitwiseOp;
    bitwiseAnd(x: number | bigint | string | ExactNumberType): ExactNumberType;
    bitwiseOr(x: number | bigint | string | ExactNumberType): ExactNumberType;
    bitwiseXor(x: number | bigint | string | ExactNumberType): ExactNumberType;
    shiftLeft(bitCount: number): ExactNumberType;
    shiftRight(bitCount: number): ExactNumberType;
    private getDecimalFormat;
    toFixed(decimals: number, roundingMode?: RoundingMode, trimZeros?: boolean): string;
    private toRepeatingParts;
    toRepeatingDigits(maxDigits: number | undefined): string;
    toExponential(digits: number, roundingMode?: RoundingMode, trimZeros?: boolean): string;
    toFraction(): string;
    private toFixedNumber;
    private toBase;
    toString(radix?: number, maxDigits?: number): string;
    toPrecision(digits: number, roundingMode?: RoundingMode, trimZeros?: boolean): string;
    valueOf(): number;
}
